

## 6.3　匿名共享内存的C++访问接口
为了方便应用程序使用匿名共享内存，Android系统在应用程序框架层中提供了两个C++类MemoryHeapBase和MemoryBase来创建和管理匿名共享内存。如果一个进程需要与其他进程共享一块完整的匿名共享内存，那么它就可以使用MemoryHeapBase类创建这块匿名共享内存。如果一个进程创建了一块匿名共享内存之后，只希望与其他进程共享其中的一部分，那么它就可以使用MemoryBase类来创建这块匿名共享内存。

MemoryBase类是在MemoryHeapBase类的基础上实现的，将它们实例化之后就得到一个Service组件，从而可以用来执行进程间通信，即将一块匿名共享内存从一个进程传输到另一个进程。接下来，我们首先分析MemoryHeapBase类的实现，然后再分析MemoryBase类的实现，最后通过一个应用实例来说明它们的使用方法。

### 6.3.1　MemoryHeapBase
前面提到，MemoryHeapBase类的实例是一个Service组件，相应地，它会有一个对应的Client组件。我们知道，Service组件必须要实现BnInterface接口，并且是运行在Server进程中的；而Client组件必须要实现BpInterface接口，并且是运行在Client进程中的。接下来，我们就首先分析MemoryHeapBase类在Server端的实现，然后再分析它在Client端的代理对象的实现。

#### 6.3.1.1　Server端实现
在前面的5.2小节的图5-15中，我们描述了Service组件的实现原理，现在将图中的IXXXXXX接口以及BnXXXXXX和XXXXXX类直接替换为IMemoryHeap接口以及BnMemoryHeap和MemoryHeapBase类，就可以得到MemoryHeapBase类在Server端的实现关系图，如图6-3所示。

![图6-3　MemoryHeapBase类在Server端的实现关系图](2020-12-10-16-52-29.png)

图6-3中的类按照其功能不同可以划分为三种类型。第一种类型是和业务相关的，即与匿名共享内存的创建和管理相关的，它们包括三个类IMemoryHeap、BnMemoryHeap和MemoryHeapBase；第二种类型是和Binder进程间通信机制相关的，它们包括六个类IInterface、IBinder、BBinder、BnInterface、ProcessState和IPCThreadState；第三种类型是和智能指针相关的，即RefBase类。在前面的第3章和第5章中，我们已经分析过后面两种类型的类的实现了，因此，在本节中，我们只关注与匿名共享内存创建和管理相关的三个类IMemoryHeap、BnMemoryHeap和MemoryHeapBase的实现。

IMemoryBase类定义了MemoryHeapBase服务接口，它包含了四个成员函数getHeapID、getBase、getSize和getFlags，分别用来获取一个匿名共享内存块的文件描述符、映射地址、大小和访问保护位，它们的定义如下所示。

`frameworks/base/include/binder/IMemory.h`
```cpp
01 class IMemoryHeap : public IInterface
02 {
03 public:
04     ......
05 
06     virtual int         getHeapID() const = 0;
07     virtual void*       getBase() const = 0;
08     virtual size_t      getSize() const = 0;
09     virtual uint32_t    getFlags() const = 0;
10 
11     ......
12 };
```
BnMemoryHeap类是一个Binder本地对象类，它只有一个成员函数onTransact，用来处理Client进程发送过来的HEAP_ID请求，如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
01 status_t BnMemory::onTransact(
02     uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
03 {
04     switch(code) {
05         case GET_MEMORY: {
06             CHECK_INTERFACE(IMemory, data, reply);
07             ssize_t offset;
08             size_t size;
09             reply->writeStrongBinder( getMemory(&offset, &size)->asBinder() );
10             reply->writeInt32(offset);
11             reply->writeInt32(size);
12             return NO_ERROR;
13         } break;
14         default:
15             return BBinder::onTransact(code, data, reply, flags);
16     }
17 }
```
第7行到第9行代码分别调用由其子类重写的成员函数getHeapID、getSize和getFlags来获取一个匿名共享内存块的文件描述符、大小和访问保护位，并且将它们写入到Parcel对象reply中，以便可以将它们返回给Client进程。
MemoryHeapBase类用来描述一个匿名共享内存服务，它继承了BnMemoryHeap类，并且实现了IMemoryBase接口的四个成员函数getHeapID、getBase、getSize和getFlags，它的定义如下所示。

`frameworks/base/include/binder/MemoryHeapBase.h`
```cpp
01 class MemoryHeapBase : public virtual BnMemoryHeap 
02 {
03 public:
04     ......
05     
06     /*
07      * maps memory from ashmem, with the given name for debugging
08      */
09     MemoryHeapBase(size_t size, uint32_t flags = 0, char const* name = NULL);
10 
11     virtual ~MemoryHeapBase();
12 
13     /* implement IMemoryHeap interface */
14     virtual int         getHeapID() const;
15     virtual void*       getBase() const;
16     virtual size_t      getSize() const;
17     virtual uint32_t    getFlags() const;
18     ......
19 private:
20     status_t mapfd(int fd, size_t size, uint32_t offset = 0);
21 
22     int         mFD;
23     size_t      mSize;
24     void*       mBase;
25     uint32_t    mFlags;
26     const char* mDevice;
27     bool        mNeedUnmap;
28 };
```
成员变量mFD是一个文件描述符，它是打开设备文件/dev/ashmem后得到的，用来描述一个匿名共享内存块；成员变量mSize、mBase和mFlags分别用来描述这块匿名共享内存块的一个匿名共享内存块；成员变量mSize、mBase和mFlags分别用来描述这块匿名共享内存块的大小、映射地址和访问保护位。

匿名共享内存服务MemoryHeapBase的内部包含了一块匿名共享内存，它的创建过程如下所示。

`frameworks/base/libs/binder/MemoryHeapBase.cpp`
```cpp
01 MemoryHeapBase::MemoryHeapBase(size_t size, uint32_t flags, char const * name)
02     : mFD(-1), mSize(0), mBase(MAP_FAILED), mFlags(flags),
03       mDevice(0), mNeedUnmap(false)
04 {
05     const size_t pagesize = getpagesize();
06     size = ((size + pagesize-1) & ~(pagesize-1));
07     int fd = ashmem_create_region(name == NULL ? "MemoryHeapBase" : name, size);
08     LOGE_IF(fd<0, "error creating ashmem region: %s", strerror(errno));
09     if (fd >= 0) {
10         if (mapfd(fd, size) == NO_ERROR) {
11             if (flags & READ_ONLY) {
12                 ashmem_set_prot_region(fd, PROT_READ);
13             }
14         }
15     }
16 }
```
参数size、flags和name分别表示要创建的匿名共享内存块的大小、访问保护位和名称，其中，参数name是可选的。

Ashmem驱动程序为应用程序创建的匿名共享内存的大小是以页面为单位的，因此，第5行首先调用函数getpagesize获得一个页面的大小，接着第6行将参数size的大小对齐到页面边界，即如果参数size的大小不是页面大小的倍数，那么就增加它的值，使得它的大小是一个页面大小的整数倍。

第7行调用由运行时库cutils提供的函数ashmem_create_region来创建一块匿名共享内存，它的返回值是一个文件描述符fd。

**注意**
> 如果没有指定要创建的匿名共享内存的名称，即参数name的值为NULL，那么第7行就会使用“MemoryHeapBase”作为要创建的匿名共享内存的名称。

接着第10行调用成员函数mapfd将前面所创建的匿名共享内存块映射到进程的地址空间。最后第11行检查所创建的匿名共享内存块是否是只读的，即参数flags的READ_ONLY位是否等于1。如果是，那么第12行就调用由运行时库cutils提供的函数ashmem_set_prot_region来设置前面所创建的匿名共享内存的访问保护位。

在前面的6.2小节中，我们已经分析过函数ashmem_create_region和ashmem_set_prot_region的实现了。因此，接下来我们就重点分析MemoryHeapBase类的成员函数mapfd的实现，它的定义如下所示。

`frameworks/base/libs/binder/MemoryHeapBase.cpp`
```cpp
01 status_t MemoryHeapBase::mapfd(int fd, size_t size, uint32_t offset)
02 {
03     ......
04 
05     if ((mFlags & DONT_MAP_LOCALLY) == 0) {
06         void* base = (uint8_t*)mmap(0, size,
07                 PROT_READ|PROT_WRITE, MAP_SHARED, fd, offset);
08         if (base == MAP_FAILED) {
09             ......
10             close(fd);
11             return -errno;
12         }
13         ......
14         mBase = base;
15         mNeedUnmap = true;
16     } else  {
17         mBase = 0; // not MAP_FAILED
18         mNeedUnmap = false;
19     }
20     mFD = fd;
21     mSize = size;
22     return NO_ERROR;
23 }
```
如果MemoryHeapBase服务的成员变量mFlags的DONT_MAP_LOCALLY位等于1，即第5行的if语句为false，就表示不要将它内部的匿名共享内存块映射到进程的地址空间。这时候第17行将这块匿名共享内存映射到进程地址空间的开始地址mBase设置为0，并且第18行将成员变量mNeedUnmap的值设置为false，表示当这个MemoryHeapBase服务被销毁时，不需要撤销它内部的匿名共享内存的内存映射。

如果MemoryHeapBase服务的成员变量mFlags的DONT_MAP_LOCALLY位等于0，即第5行的if语句为true，那么第6行和第7行就调用函数mmap将它内部的匿名共享内存映射到进程的地址空间。接着第14行将获得的映射地址保存在成员变量mBase中，并且第15行将它的成员变量mNeedUnmap的值设置为true，表示当这个MemoryHeapBase服务被销毁时，需要撤销它内部的匿名共享内存的内存映射。

**注意**
> 在将这块匿名共享内存映射到进程的地址空间时，指定这块匿名共享内存的访问保护位为PROT_READ|PROT_WRITE，即只可以对它进行读写，同时，指定要映射的虚拟内存地址的内容是可以和其他进程共享的。

MemoryHeapBase服务的另外四个成员函数getHeapID、getBase、getSize和getFlags的实现如下所示。

`frameworks/base/libs/binder/MemoryHeapBase.cpp`
```cpp
01 int MemoryHeapBase::getHeapID() const {
02     return mFD;
03 }
04 
05 void* MemoryHeapBase::getBase() const {
06     return mBase;
07 }
08 
09 size_t MemoryHeapBase::getSize() const {
10     return mSize;
11 }
12 
13 uint32_t MemoryHeapBase::getFlags() const {
14     return mFlags;
15 }
```
它们分别将一个MemoryHeapBase服务内部的匿名共享内存块的文件描述符mFD、映射地址mBase、大小mSize和访问保护位mFlags返回给调用者。

至此，MemoryHeapBase类在Server端的实现就分析完成了，它主要是通过调用运行时库cutils提供的匿名共享内存接口在内部创建一块可以与其他进程共享的匿名共享内存。接下来，我们继续分析MemoryHeapBase类在Client端的实现。

#### 6.3.1.2　Client端实现
MemoryHeapBase类在Client端主要是实现一个类型为BpMemoryHeap的Client组件，即一个实现了IMemoryHeap接口的Binder代理对象，通过它可以获得运行在Server端的MemoryHeapBase服务内部的匿名共享内存块的文件描述符、大小和访问保护位。有了这个匿名共享内存块的信息之后，Client端就可以将它映射到Client进程的地址空间，从而可以访问在Server端创建的匿名共享内存块。
根据前面5.2小节中的图5-16所描述的Client组件实现原理图，我们将图中的IXXXXXX接口和BpXXXXXX类直接替换为IMemoryHeap接口和BpMemoryHeap类，就可以得到MemoryHeapBase类在Client端的实现关系图，如图6-4所示。

![图6-4　MemoryHeapBase类在Client端的实现关系图](2020-12-10-17-06-46.png)

图6-4中的类按照其功能不同可以划分为三种类型。第一种类型是和业务相关的，即与匿名共享内存的创建和管理相关的，它们包括两个类IMemoryHeap和BpMemoryHeap；第二种类型是和Binder进程间通信机制相关的，它们包括七个类IInterface、IBinder、BpRefBase、BpBinder、BpInterface、ProcessState和IPCThreadState；第三种类型是和智能指针相关的，即RefBase类。在前面的第3章、第5章以及6.3.1.1小节中，我们已经分析过后面两种类型的类以及IMemoryHeap类的实现了，因此，在本节中，我们只关注BpMemoryHeap类的实现。

BpMemoryHeap类用来描述一个MemoryHeapBase服务的代理对象，它的定义如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
01 class BpMemoryHeap : public BpInterface<IMemoryHeap>
02 {
03 public:
04     BpMemoryHeap(const sp<IBinder>& impl);
05     virtual ~BpMemoryHeap();
06 
07     virtual int getHeapID() const;
08     virtual void* getBase() const;
09     virtual size_t getSize() const;
10     virtual uint32_t getFlags() const;
11 
12     ......
13 
14     mutable volatile int32_t mHeapId;
15     mutable void*       mBase;
16     mutable size_t      mSize;
17     mutable uint32_t    mFlags;
18     ......
19 };
```

成员变量mHeapId是一个文件描述符，它是通过请求MemoryHeapBase服务获得的，用来描述一个匿名共享内存块；成员变量mBase、mSize和mFlags分别用来描述这块匿名共享内存的地址、大小和访问保护位。

BpMemoryHeap类所描述的MemoryHeapBase代理对象的创建过程如下所示：

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
1 BpMemoryHeap::BpMemoryHeap(const sp<IBinder>& impl)
2     : BpInterface<IMemoryHeap>(impl),
3         mHeapId(-1), mBase(MAP_FAILED), mSize(0), mFlags(0), mRealHeap(false)
4 {
5 }
```
参数impl指向一个Binder代理对象，它引用了运行在Server端的一个MemoryHeapBase服务，第2行使用它初始化父类BpInterface。
第3行分别将一个MemoryHeapBase代理对象的成员变量mHeapId、mBase、mSize和mFlags的值设置为-1、MAP_FAILED、0和0，表示该MemoryHeapBase代理对象内部的匿名共享内存尚未映射到Client进程的地址空间。

当Client进程第一次访问这个MemoryHeapBase代理对象内部的匿名共享内存块时，它就会请求运行在Server端的MemoryHeapBase服务返回其内部的匿名共享内存块的信息，然后根据返回的信息将这块匿名共享内存映射到Client进程的地址空间，最后就可以访问这块匿名共享内存了。

MemoryHeapBase代理对象的另外四个成员函数getHeapID、getBase、getSize和getFlags的实现如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
01 int BpMemoryHeap::getHeapID() const {
02     assertMapped();
03     return mHeapId;
04 }
05 
06 void* BpMemoryHeap::getBase() const {
07     assertMapped();
08     return mBase;
09 }
10 
11 size_t BpMemoryHeap::getSize() const {
12     assertMapped();
13     return mSize;
14 }
15 
16 uint32_t BpMemoryHeap::getFlags() const {
17     assertMapped();
18     return mFlags;
19 }
```
它们分别将一个MemoryHeapBase代理对象内部的匿名共享内存块的文件描述符mHeapId、地址mBase、大小mSize和访问保护位mFlags返回给调用者。

当这四个成员函数的其中一个第一次被调用时，成员函数assertMapped就会被调用来请求运行在Server端的MemoryHeapBase服务，返回其内部的匿名共享内存块的文件描述符、大小和访问保护位，以便可以将这块匿名共享内存映射到Client进程的地址空间。

MemoryHeapBase代理对象的成员函数assertMapped的实现如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
01 void BpMemoryHeap::assertMapped() const
02 {
03     if (mHeapId == -1) {
04         sp<IBinder> binder(const_cast<BpMemoryHeap*>(this)->asBinder());
05         sp<BpMemoryHeap> heap(static_cast<BpMemoryHeap*>(find_heap(binder).get()));
06         heap->assertReallyMapped();
07         if (heap->mBase != MAP_FAILED) {
08             Mutex::Autolock _l(mLock);
09             if (mHeapId == -1) {
10                 mBase   = heap->mBase;
11                 mSize   = heap->mSize;
12                 android_atomic_write( dup( heap->mHeapId ), &mHeapId );
13             }
14         } else {
15             // something went wrong
16             free_heap(binder);
17         }
18     }
19 }
```
第3行判断一个MemoryHeapBase代理对象的成员变量mHeapId的值是否等于-1。如果等于-1，那么就说明它尚未将运行在Server端的MemoryHeapBase服务内部的匿名共享内存块映射到Client进程的地址空间来。因此，第4行到第6行代码就会先请求运行在Server端的MemoryHeapBase服务返回其内部的匿名共享内存块的信息，然后根据这些信息将这块匿名共享内存映射到Client进程的地址空间。

Binder库为Client进程维护了一个类型为HeapCache的强指针gHeapCache，它的定义如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
static sp<HeapCache> gHeapCache = new HeapCache();
```
在Client进程中，可能会存在多个不同的MemoryHeapBase代理对象引用了同一个MemoryHeapBase服务的情况，在这种情况下，它们内部都引用了同一个Binder代理对象。当其中一个MemoryHeapBase代理对象请求运行在Server端的MemoryHeapBase服务返回其内部的匿名共享内存块的信息之后，它就可以将这块匿名共享内存映射到Client进程的地址空间了。这时候，其他的MemoryHeapBase代理对象就没有必要再将这块匿名共享内存映射到Client进程的地址空间了。

HeapCache类的定义如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
01 class HeapCache : public IBinder::DeathRecipient
02 {
03 public:
04     ......
05 
06     sp<IMemoryHeap> find_heap(const sp<IBinder>& binder); 
07     ......
08     sp<IMemoryHeap> get_heap(const sp<IBinder>& binder);
09     ......
10 
11 private:
12     // For IMemory.cpp
13     struct heap_info_t {
14         sp<IMemoryHeap> heap;
15         int32_t         count;
16     };
17     
18     ......
19     
20     KeyedVector< wp<IBinder>, heap_info_t > mHeapCache;
21 };
```
HeapCache类内部有一个成员变量mHeapCache，用来描述一个类型为KeyedVector的列表。列表mHeapCache中保存的是Client进程的MemoryHeapBase代理对象，这些MemoryHeapBase代理对象分别使用一个heap_info_t结构体来描述，并且以一个指向它们内部的Binder代理对象的弱指针作为关键字保存在列表mHeapCache中。

由于在Client进程中，引用了同一个MemoryHeapBase服务的不同MemoryHeapBase代理对象都引用了同一个Binder代理对象，因此，当第一个MemoryHeapBase代理对象请求运行在Server端的MemoryHeapBase服务返回其内部的匿名共享内存块的信息时，它就会将自己保存在全局变量gHeapCache内部的列表mHeapCache中。这样，其他的MemoryHeapBase代理对象就可以通过内部的同一个Binder代理对象在全局变量gHeapCache内部的列表mHeapCache中找到第一个MemoryHeapBase代理对象，从而可以获得已经映射到Client进程中的匿名共享内存块的信息。

回到MemoryHeapBase代理对象的成员函数assertMapped中，第4行首先获得一个MemoryHeapBase代理对象内部的Binder代理对象binder，接着第5行将这个Binder代理对象作为参数来调用成员函数find_heap，试图在全局变量gHeapCache中找到一个MemoryHeapBase代理对象heap。找到的MemoryHeapBase代理对象heap就是第一个请求运行在Server端的MemoryHeapBase服务返回其内部的匿名共享内存块的信息的MemoryHeapBase代理对象。

MemoryHeapBase代理对象的成员函数find_heap的实现如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
class BpMemoryHeap : public BpInterface<IMemoryHeap>
{
    ......
    
    static inline sp<IMemoryHeap> find_heap(const sp<IBinder>& binder) {
        return gHeapCache->find_heap(binder);
    }
        ......
};
```
它调用了全局变量gHeapCache的成员函数find_heap找到一个与Binder代理对象binder对应的MemoryHeapBase代理对象。

HeapCache类的成员函数find_heap的实现如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
01 sp<IMemoryHeap> HeapCache::find_heap(const sp<IBinder>& binder) 
02 {
03     Mutex::Autolock _l(mHeapCacheLock);
04     ssize_t i = mHeapCache.indexOfKey(binder);
05     if (i>=0) {
06         heap_info_t& info = mHeapCache.editValueAt(i);
07         ......
08         android_atomic_inc(&info.count);
09         return info.heap;
10     } else {
11         heap_info_t info;
12         info.heap = interface_cast<IMemoryHeap>(binder);
13         info.count = 1;
14         ......
15         mHeapCache.add(binder, info);
16         return info.heap;
17     }
18 }
```
第4行以Binder代理对象binder作为关键字，试图在列表mHeapCache中找到一个对应的heap_info_t结构体。

如果能成功地找到一个对应的heap_info_t结构体，即第5行的if语句为true，那么第9行就将这个heap_info_t结构体的成员变量heap所指向的一个MemoryHeapBase代理对象返回给调用者。在返回之前，第8行会增加这个heap_info_t结构体的成员变量count的值，表示与这个heap_info_t结构体对应的MemoryHeapBase代理对象又多了一个引用者。

如果不能找到一个对应的heap_info_t结构体，即第5行的if语句为false，那么第11行到第13行代码就会先创建一个heap_info_t结构体info，并且将它的成员变量heap指向在内部引用了Binder代理对象binder的MemoryHeapBase代理对象。接着第15行代码就以Binder代理对象binder作为关键字，将heap_info_t结构体info保存在列表mHeapCache中。最后第16行将heap_info_t结构体info的成员变量heap所指向的MemoryHeapBase代理对象返回给调用者。

回到MemoryHeapBase代理对象的成员函数assertMapped中，第6行调用前面所获得的MemoryHeapBase代理对象heap的成员函数assertReallyMapped，来请求运行在Server端的MemoryHeapBase服务返回其内部的匿名共享内存块的信息，并且将该匿名共享内存块映射到Client进程的地址空间，最后就得到该匿名共享内存块在Client进程的映射地址、大小和文件描述符了，分别保存在MemoryHeapBase代理对象heap的成员变量mBase、mSize和mHeapId中。

**注意**
> 第10行到第12行代码在将MemoryHeapBase代理对象heap的成员变量mBase、mSize和mHeapId拷贝到当前MemoryHeapBase代理对象的成员变量mBase、mSize和mHeapId之前，为什么第9行的if语句需要重复判断当前MemoryHeapBase代理对象的成员变量mHeapId是否等于-1呢？前面第3行的if语句不是已经判断过了吗？这是因为当前MemoryHeapBase代理对象与MemoryHeapBase代理对象heap可能是同一个MemoryHeapBase代理对象，因此，为了避免将自己的成员变量mBase、mSize和mHeapId重复拷贝给自己，第9行就需要再次判断当前MemoryHeapBase代理对象的成员变量mHeapId是否等于-1。

接下来，我们继续分析MemoryHeapBase代理对象的成员函数assertReallyMapped是如何请求运行在Server端的MemoryHeapBase服务返回其内部的匿名共享内存块的信息的。

MemoryHeapBase代理对象的成员函数assertReallyMapped的实现如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
01 void BpMemoryHeap::assertReallyMapped() const
02 {
03     if (mHeapId == -1) {
04         ......
05         
06         Parcel data, reply;
07         data.writeInterfaceToken(IMemoryHeap::getInterfaceDescriptor());
08         status_t err = remote()->transact(HEAP_ID, data, &reply);
09         int parcel_fd = reply.readFileDescriptor();
10         ssize_t size = reply.readInt32();
11         uint32_t flags = reply.readInt32();
12 
13         ......
14 
15         int fd = dup( parcel_fd );
16         ......
17 
18         int access = PROT_READ;
19         if (!(flags & READ_ONLY)) {
20             access |= PROT_WRITE;
21         }
22 
23         Mutex::Autolock _l(mLock);
24         if (mHeapId == -1) {
25             mRealHeap = true;
26             mBase = mmap(0, size, access, MAP_SHARED, fd, 0);
27             if (mBase == MAP_FAILED) {
28               ......
29                 close(fd);
30             } else {
31                 mSize = size;
32                 mFlags = flags;
33                 android_atomic_write(fd, &mHeapId);
34             }
35         }
36     }
37 }
```
第3行首先判断成员变量mHeapId的值是否等于-1。如果不等于-1，那么就说明该MemoryHeapBase代理对象已经请求过运行在Server端的MemoryHeapBase服务返回其内部的匿名共享内存块的信息了。因此，这时候函数什么也不用做就可以返回了。

第8行通过成员函数remote来获得该MemoryHeapBase代理对象内部的Binder代理对象，接着再调用这个Binder代理对象的成员函数transact向运行在Server端的MemoryHeapBase服务发送一个类型为HEAP_ID的进程间通信请求，即请求该MemoryHeapBase服务返回其内部的匿名共享内存的文件描述符、大小和访问保护位。

MemoryHeapBase服务将其内部的匿名共享内存的文件描述符经过Binder驱动程序返回给Client进程时，Binder驱动程序会在Client进程中复制这个文件描述符，使得它指向MemoryHeapBase服务中的匿名共享内存。在后面的6.5小节中，我们再详细描述这个过程。

获得了一个指向运行在Server端的MemoryHeapBase服务内部的匿名共享内存的文件描述符之后，接着第26行就可以调用函数mmap将这块匿名共享内存映射到Client进程的地址空间，最后就可以获得它的地址，并且保存在成员变量mBase中。这样，Client进程就可以通过这个地址来访问这块匿名共享内存了，即与Server端共享了同一块匿名共享内存。
**注意**
> 第26行调用函数mmap将运行在Server端的MemoryHeapBase服务内部的匿名共享内存映射到Client进程的地址空间之前，为什么第24行的if语句需要重复判断当前MemoryHeapBase代理对象的成员变量mHeapId是否等于-1呢？前面第3行的if语句不是已经判断过了吗？这是因为第8行的代码是一个同步的Binder进程间通信过程，在通信过程中，当前线程可能会进入睡眠状态。在当前线程进入睡眠状态的过程中，可能其他线程正在调用当前BpMemoryHeap对象的成员函数assertReallyMapped来请求运行在Server端的MemoryHeapBase服务返回其内部的匿名共享内存的信息。当这个其他的线程先于当前线程获得这块匿名共享内存的信息时，它就会将这块匿名共享内存映射到Client进程的地址空间。因此，第24行的if语句就需要重复判断当前BpMemoryHeap对象的成员变量mHeapId的值是否等于-1。的地址空间。因此，第24行的if语句就需要重复判断当前BpMemoryHeap对象的成员变量mHeapId的值是否等于-1。如果不等于，那么就不需要重复将这块匿名共享内存映射到Client进程的地址空间了。

至此，MemoryHeapBase类在Server端和Client端的实现就分析完成了。接下来，我们继续分析另外一个匿名共享内存的C++访问接口MemoryBase的实现。

### 6.3.2　MemoryBase
前面提到，MemoryBase类是在MemoryHeapBase类的基础上实现的，它们都可以用来描述一个匿名共享内存服务，它们的关系如图6-5所示。

![图6-5　MemoryBase类和MemoryHeapBase类的关系图](2020-12-10-17-20-15.png)

MemoryBase类内部有一个类型为IMemoryHeap的强指针mHeap，它指向一个MemoryHeapBase服务，MemoryBase类就是通过它来描述一个匿名共享内存服务的。MemoryBase类所维护的匿名共享内存其实只是其内部的MemoryHeapBase服务所维护的匿名共享内存的其中一小块。这一小块匿名共享内存用另外两个成员变量mOffset和mSize来描述，其中，mOffset表示这一小块匿名共享内存在一块完整的匿名共享内存中的偏移值；mSize则表示这一小块匿名共享内存的大小。
类似于MemoryHeapBase类，MemoryBase类的实现也分为Server端和Client端两个部分，因此，接下来我们首先分析它在Server端的实现，然后再分析它在Client端的实现。

#### 6.3.2.1　Server端实现
在前面的5.2小节的图5-15中，我们描述了Service组件的实现原理，现在将图中的IXXXXXX接口以及BnXXXXXX和XXXXXX类直接替换为IMemory接口以及BnMemory和MemoryBase类，就可以得到MemoryBase类在Server端的实现关系图，如图6-6所示。

![图6-6　MemoryBase类在Server端的实现关系图](2020-12-10-17-21-15.png)

MemoryBase类在Server端的实现与MemoryHeapBase类在Server端的实现类似，只要将图6-6中的三个类IMemory、BnMemory和MemoryBase分别替换成IMemoryHeap、BnMemoryHeap和MemoryHeapBase类，就可以得到图6-3所描述的MemoryHeapBase类在Server端的实现关系图。接下来我们主要分析三个类IMemory、BnMemory和MemoryBase的实现。

IMemory类定义了MemoryBase服务接口，它主要包含四个成员函数getMemory、pointer、size和offset，它们的定义如下所示。

`frameworks/base/include/binder/IMemory.h`
```cpp
01 class IMemory : public IInterface
02 {
03 public:
04     DECLARE_META_INTERFACE(Memory);
05     virtual sp<IMemoryHeap> getMemory(ssize_t* offset=0, size_t* size=0) const = 0;
06 
07     void* fastPointer(const sp<IBinder>& heap, ssize_t offset) const;
08     void* pointer() const;
09     size_t size() const;
10     ssize_t offset() const;
11 };
```
成员函数getMemory用来获取一个MemoryBase服务内部的MemoryHeapBase服务。当它被调用时，如果指定的参数offset和size不等于NULL，那么它还会返回这个MemoryBase服务内部的一小块匿名共享内存的偏移值和大小，这两个信息同样可以通过成员函数size和offset来获取。成员函数pointer用来获取一个MemoryBase服务内部的小块匿名共享内存的地址。

在这四个成员函数中，只有getMemory是纯虚函数，需要由其子类来重写，其余三个成员函数是由IMemory类实现的，如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
01 void* IMemory::pointer() const {
02     ssize_t offset;
03     sp<IMemoryHeap> heap = getMemory(&offset);
04     void* const base = heap!=0 ? heap->base() : MAP_FAILED;
05     if (base == MAP_FAILED)
06         return 0;
07     return static_cast<char*>(base) + offset;
08 }
09 
10 size_t IMemory::size() const {
11     size_t size;
12     getMemory(NULL, &size);
13     return size;
14 }
15 
16 ssize_t IMemory::offset() const {
17     ssize_t offset;
18     getMemory(&offset);
19     return offset;
20 }
```
成员函数pointer首先调用由其子类重写的成员函数getMemory来获取一个MemoryHeapBase服务heap，以及一个偏移值offset，接着再获得这个MemoryHeapBase服务内部的匿名共享内存的地址base，最后将变量base和offset的值相加，就得到了一个MemoryBase服务内部的一小块匿名共享内存的地址。成员函数size和offset也是通过调用由子类重写的成员函数getMemory来获取一个MemoryBase服务内部的一小块匿名共享内存的大小和偏移值的。

BnMemory类是一个Binder本地对象类，它只有一个成员函数onTransact，用来处理Client进程发送过来的GET_MEMORY请求，如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
01 status_t BnMemory::onTransact(
02     uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
03 {
04     switch(code) {
05         case GET_MEMORY: {
06             CHECK_INTERFACE(IMemory, data, reply);
07             ssize_t offset;
08             size_t size;
09             reply->writeStrongBinder( getMemory(&offset, &size)->asBinder() );
10             reply->writeInt32(offset);
11             reply->writeInt32(size);
12             return NO_ERROR;
13         } break;
14         default:
15             return BBinder::onTransact(code, data, reply, flags);
16     }
17 }
```
第9行首先调用由其子类实现的成员函数getMemory来获得一个MemoryHeapBase服务，以及一小块匿名共享内存的偏移值和大小，接着再将它们写入到Parcel对象reply中，以便可以将它们返回给Client进程。

MemoryBase类用来描述一个匿名共享内存服务，它继承了BnMemory类，并且实现了IMemory接口的成员函数getMemory，它的定义如下所示。

`frameworks/base/libs/binder/MemoryBase.cpp`
```cpp
01 class MemoryBase : public BnMemory 
02 {
03 public:
04     MemoryBase(const sp<IMemoryHeap>& heap, ssize_t offset, size_t size);
05     virtual ~MemoryBase();
06     virtual sp<IMemoryHeap> getMemory(ssize_t* offset, size_t* size) const;
07 
08     ......
09 
10 private:
11     size_t          mSize;
12     ssize_t         mOffset;
13     sp<IMemoryHeap> mHeap;
14 };
```
成员变量mHeap指向一个MemoryHeapBase服务；成员变量mSize和mOffset分别用来描述一小块匿名共享内存的大小和偏移值，它们都是在构造函数中初始化的，如下所示。

`frameworks/base/libs/binder/MemoryBase.cpp`
```cpp
MemoryBase::MemoryBase(const sp<IMemoryHeap>& heap,
        ssize_t offset, size_t size)
    : mSize(size), mOffset(offset), mHeap(heap)
{
}
```
MemoryBase类的成员函数getMemory的实现如下所示。

`frameworks/base/libs/binder/MemoryBase.cpp`
```cpp
1 sp<IMemoryHeap> MemoryBase::getMemory(ssize_t* offset, size_t* size) const
2 {
3     if (offset) *offset = mOffset;
4     if (size)   *size = mSize;
5     return mHeap;
6 }
```
第3行和第4行的if语句分别判断参数offset和size的值是否不等于NULL。如果不等于，那么函数就分别将成员变量mOffset和mSize所描述的一小块匿名共享内存的偏移值和大小设置到它们的地址中。最后第5行将成员变量mHeap所指向的一个MemoryHeapBase服务返回给调用者。

至此，MemoryBase类在Server端的实现就分析完成了，它主要通过一个MemoryHeapBase服务在内部维护一小块可以与其他进程共享的匿名共享内存。接下来，我们继续分析MemoryBase类在Client端的实现。

#### 6.3.2.2　Client端实现
MemoryBase类在Client端主要是实现一个类型为BpMemory的Client组件，即一个实现了IMemory接口的Binder代理对象，通过它可以获得运行在Server端的MemoryBase服务内部的一小块匿名共享内存的偏移值和大小，以及一个MemoryHeapBase代理对象。有了这个MemoryHeapBase代理对象之后，Client端就可以将在Server端创建的一块匿名共享内存映射到自己的地址空间了。

根据前面5.2小节中的图5-16所描述的Client组件实现原理图，我们将图中的IXXXXXX接口和BpXXXXXX类直接替换为IMemory接口和BpMemory类，就可以得到MemoryBase类在Client端的实现关系图，如图6-7所示。

![图6-7　MemoryBase类在Client端的实现关系图](2020-12-10-17-29-47.png)

MemoryBase类在Client端的实现与MemoryHeapBase类在Client端的实现类似，只要把图6-7中的两个类IMemory和BpMemory分别替换成IMemoryHeap和BpMemoryHeap类，就可以得到图6-4所描述的MemoryHeapBase类在Client端的实现关系图了。在前面的6.3.2.1小节中，我们已经分析过IMemory类的实现了，因此，在本节中，我们只关注BpMemory类的实现。


BpMemory类用来描述一个MemoryBase服务的代理对象，它的定义如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
01 class BpMemory : public BpInterface<IMemory>
02 {
03 public:
04     BpMemory(const sp<IBinder>& impl);
05     virtual ~BpMemory();
06     virtual sp<IMemoryHeap> getMemory(ssize_t* offset=0, size_t* size=0) const;
07     
08 private:
09     mutable sp<IMemoryHeap> mHeap;
10     mutable ssize_t mOffset;
11     mutable size_t mSize;
12 };
```
成员变量mHeap指向一个MemoryHeapBase代理对象；成员变量mOffset和mSize分别用来描述一小块匿名共享内存的偏移值和大小。

BpMemory类所描述的MemoryBase代理对象的创建过程如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
BpMemory::BpMemory(const sp<IBinder>& impl)
    : BpInterface<IMemory>(impl), mOffset(0), mSize(0)
{
}
```
参数impl指向一个Binder代理对象，它引用了运行在Server端的一个MemoryBase服务，第2行使用它初始化父类Bplnterface。第2行还将一个MemoryBase代理对象的成员变量mOffset和mSize的值设置为0，表示该MemoryBase代理对象内部的一小块匿名共享内存尚未映射到Client进程的地址空间。

当Client进程第一次访问这个MemoryBase代理对象内部的一小块匿名共享内存时，它就会请求运行在Server端的MemoryBase服务返回其内部的一个MemoryHeapBase服务代理对象，然后通过这个MemoryHeapBase代理对象将在Server端创建的一块匿名共享内存映射到Client进程的地址空间。

BpMemory类的成员函数getMemory的实现如下所示。

`frameworks/base/libs/binder/IMemory.cpp`
```cpp
01 sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
02 {
03     if (mHeap == 0) {
04         Parcel data, reply;
05         data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
06         if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
07             sp<IBinder> heap = reply.readStrongBinder();
08             ssize_t o = reply.readInt32();
09             size_t s = reply.readInt32();
10             if (heap != 0) {
11                 mHeap = interface_cast<IMemoryHeap>(heap);
12                 if (mHeap != 0) {
13                     mOffset = o;
14                     mSize = s;
15                 }
16             }
17         }
18     }
19     if (offset) *offset = mOffset;
20     if (size) *size = mSize;
21     return mHeap;
22 }
```
第3行的if语句判断一个MemoryBase代理对象的成员变量mHeap的值是否等于0。如果不等于0，那么就说明该MemoryBase代理对象已经请求过运行在Server端的MemoryBase服务返回其内部的一个MemoryHeapBase服务代理对象，以及一小块匿名共享内存的信息了。因此，第19行到第21行代码就可以直接将这一小块匿名共享内存的偏移值mOffset和大小mSize，以及这个MemoryHeapBase代理对象mHeap返回给调用者了。

第6行首先通过成员函数remote来获得该MemoryBase代理对象内部的Binder代理对象，然后调用这个Binder代理对象的成员函数transact向运行在Server端的MemoryBase服务发送一个类型为GET_MEMORY的进程间通信请求，即请求该MemoryBase服务返回其内部的一个MemoryHeapBase服务代理对象，以及一小块匿名共享内存的偏移值和大小。接着第8行到第16行代码将这个MemoryHeapBase代理对象，以及这一小块匿名共享内存的偏移值和大小分别保存在该MemoryBase代理对象的成员变量mHeap、mOffset和mSize中。最后第19行到第21行代码将这些信息返回给调用者。
至此，MemoryBase类在Server端和Client端的实现就分析完成了。接下来，我们通过一个应用实例来说明它们的使用方法。

### 6.3.3　应用实例
在本节中，我们将创建两个应用程序SharedBufferServer和SharedBufferClient。应用程序SharedBufferServer在启动时，会创建一个共享缓冲区服务SharedBufferService，并且将它注册到Service Manager中，以便可以提供一段共享缓冲区给其他应用程序使用。应用程序SharedBufferClient在启动时，会请求Service Manager返回在应用程序SharedBufferServer中创建的共享缓冲区服务SharedBufferService的一个代理对象，接着就通过这个代理对象将在应用程序SharedBufferServer中创建的一段共享缓冲区映射到本进程的地址空间，最后就可以使用这段共享缓冲区了。共享缓冲区服务SharedBufferService实现了共享缓冲区服务接口ISharedBuffer，它是在匿名共享内存服务MemoryBase的基础上来实现一段共享缓冲区的。

应用程序SharedBufferServer和SharedBufferClient由三个模块组成：第一个是公共模块，用来定义SharedBufferService服务接口ISharedBuffer、Binder本地对象类BnSharedBuffer和Binder代理对象类BpSharedBuffer；第二个是Server端模块，用来实现应用程序SharedBufferServer；第三个是Client端模块，用来实现应用程序SharedBufferClient。

这三个模块的目录结构如下：

```bash
---- common
    ---- IShareBuffer.h
    ---- IShareBuffer.cpp
---- server
    ---- ShareBufferServer.cpp
    ---- Android.mk
---- client
    ---- ShareBufferClient.cpp
    ---- Android.mk
```
common模块由文件ISharedBuffer.h和ISharedBuffer.cpp组成，server模块由文件SharedBufferServer.cpp和Android.mk组成；client模块由文件SharedBufferClient.cpp和Android.mk组成。接下来，我们就分别介绍各个文件的内容。







