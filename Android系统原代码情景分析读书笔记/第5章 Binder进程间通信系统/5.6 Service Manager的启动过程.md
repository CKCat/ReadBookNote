
## 5.6　Service Manager的启动过程
Service Manager是Binder进程间通信机制的核心组件之一，它扮演着Binder进程间通信机制上下文管理者（Context Manager）的角色，同时负责管理系统中的Service组件，并且向Client组件提供获取Service代理对象的服务。

Service Manager运行在一个独立的进程中，因此，Service组件和Client组件也需要通过进程间通信机制来和它交互，而采用的进程间通信机制正好也是Binder进程间通信机制。从这个角度来看，Service Manager除了是Binder进程间通信机制的上下文管理者（Context Manager）之外，它也是一个特殊的Service组件。

Service Manager是由init进程负责启动的，而init进程是在系统启动时启动的，因此，Service Manager也是在系统启动时启动的，它的启动脚本如下所示。

`system/core/rootdir/init.rc`
```
1 service servicemanager /system/bin/servicemanager
2     user system
3     critical
4     onrestart restart zygote
5     onrestart restart media
```
第1行的关键字service表明Service Manager是以服务的形式启动的，它对应的程序文件和进程名称分别为/system/bin/servicemanager和“servicemanager”。第2行的关键字user表明Service Manager是以系统用户system的身份运行的。第3行的关键字critical表明Service Manager是系统中的一个关键服务。在系统的运行过程中，关键服务是不可以退出的，一旦 Manager是系统中的一个关键服务。在系统的运行过程中，关键服务是不可以退出的，一旦退出，就会被系统重启，但是如果一个关键服务在4分钟内退出的次数大于4，那么系统就会重启，然后进入恢复模式。第4行和第5行的关键字onrestart表示一旦Service Manager被系统重启，也需要将zygote和media两个进程重新启动。

如前所述，Service Manager对应的程序文件为servicemanager，它的源代码目录结构如下：

```
~/Android/frameworks/base/cmd
---- servicemanager
    ---- binder.h
    ---- binder.c
    ---- service_manager.c
```
该程序的入口函数main实现在文件service_manager.c中，下面我们就从这个函数开始分析Service Manager的启动过程，它的实现如下所示。

`frameworks/base/cmds/servicemanager/service_manager.c`
```cpp
01 void *svcmgr_handle;
02 
03 int main(int argc, char **argv)
04 {
05     struct binder_state *bs;
06     void *svcmgr = BINDER_SERVICE_MANAGER;
07 
08     bs = binder_open(128*1024);
09 
10     if (binder_become_context_manager(bs)) {
11         LOGE("cannot become context manager (%s)\n", strerror(errno));
12         return -1;
13     }
14 
15     svcmgr_handle = svcmgr;
16     binder_loop(bs, svcmgr_handler);
17     return 0;
18 }
```
Service Manager的启动过程由三个步骤组成：第一步是调用函数binder_open打开设备文件/dev/binder，以及将它映射到本进程的地址空间；第二步是调用函数binder_become_context_manager将自己注册为Binder进程间通信机制的上下文管理者；第三步是调用函数binder_loop来循环等待和处理Client进程的通信请求。

在继续分析Service Manager的启动过程之前，我们首先解释一下定义在Service Manager中的结构体binder_state和宏BINDER_SERVICE_MANAGER。

结构体binder_state的定义如下所示。

`frameworks/base/cmds/servicemanager/binder.c`
```cpp
1 struct binder_state
2 {
3     int fd;
4     void *mapped;
5     unsigned mapsize;
6 };
```
Service Manager打开了设备文件/dev/binder之后，就会将得到的文件描述符保存在一个binder_state结构体的成员变量fd中，以便后面可以通过它来和Binder驱动程序交互。在前面的5.1.4小节中提到，一个进程如果要和Binder驱动程序交互，除了要打开设备文件/dev/binder之外，还需要将该设备文件映射到进程的地址空间，以便Binder驱动程序可以为它分配内核缓冲区来保存进程通信数据。因此，Service Manager就需要将设备文件/dev/binder映射到自己的进程地址空间，并且将映射后得到的地址空间大小和起始地址保存在一个binder_state结构体的成员变量mapsize和mapped中。

宏BINDER_SERVICE_MANAGER的定义如下所示。

`frameworks/base/cmds/servicemanager/binder.h`
```cpp
/* the one magic object */
#define BINDER_SERVICE_MANAGER ((void*) 0)
```
前面提到，Service Manager是一个特殊的Service组件，它的特殊之处就在于与它对应的Binder本地对象是一个虚拟的对象。这个虚拟的Binder本地对象的地址值等于0，并且在Binder驱动程序中引用了它的Binder引用对象的句柄值也等于0。

回到函数main中，第6行将变量svcmgr的值设置为BINDER_SERVICE_MANAGER，接着第15行又将它保存在全局变量svcmgr_handle中，用来描述一个与Service Manager对应的Binder本地对象。

接下来，我们就分别分析函数binder_open、binder_become_context_manager和binder_loop的实现。

### 5.6.1　打开和映射Binder设备文件
函数binder_open用来打开设备文件/dev/binder，并且将它映射到进程的地址空间，它的实现如下所示。

`frameworks/base/cmds/servicemanager/binder.c`
```cpp
01 struct binder_state *binder_open(unsigned mapsize)
02 {
03     struct binder_state *bs;
04 
05     bs = malloc(sizeof(*bs));
06     if (!bs) {
07         errno = ENOMEM;
08         return 0;
09     }
10 
11     bs->fd = open("/dev/binder", O_RDWR);
12     if (bs->fd < 0) {
13         fprintf(stderr,"binder: cannot open device (%s)\n",
14                 strerror(errno));
15         goto fail_open;
16     }
17 
18     bs->mapsize = mapsize;
19     bs->mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs->fd, 0);
20     if (bs->mapped == MAP_FAILED) {
21         fprintf(stderr,"binder: cannot map device (%s)\n",
22                 strerror(errno));
23         goto fail_map;
24     }
25 
26         /* TODO: check version */
27 
28     return bs;
29 
30 fail_map:
31     close(bs->fd);
32 fail_open:
33     free(bs);
34     return 0;
35 }
```
从前面的调用过程可以知道，参数mapsize的大小为128×1024，即128K。
第11行调用函数open打开设备文件/dev/binder。在前面的5.1.3小节中提到，当使用进程函数open打开设备文件/dev/binder时，Binder驱动程序中的函数binder_open就会被调用，它会为当前进程创建一个binder_proc结构体，用来描述当前进程的Binder进程间通信状态。

第19行调用函数mmap将设备文件/dev/binder映射到进程的地址空间，它请求映射的地址空间大小为mapsize，即请求Binder驱动程序为进程分配128K大小的内核缓冲区。映射后得到的地址空间的起始地址和大小分别保存在一个binder_state结构体bs的成员变量mapped和mapsize中。最后，第28行将binder_state结构体bs返回给调用者，即函数main。

打开了设备文件/dev/binder，以及将它映射到进程的地址空间之后，Service Manager接下来就会将自己注册为Binder进程间通信机制的上下文管理者。

### 5.6.2　注册为Binder上下文管理者
Service Manager要成为Binder进程间通信机制的上下文管理者，就必须要通过IO控制命令BINDER_SET_CONTEXT_MGR将自己注册到Binder驱动程序中，这是通过调用函数binder_become_context_manager来实现的，它的定义如下所示。

`frameworks/base/cmds/servicemanager/binder.c`
```cpp
int binder_become_context_manager(struct binder_state *bs)
{
    return ioctl(bs->fd, BINDER_SET_CONTEXT_MGR, 0);
}
```
IO控制命令BINDER_SET_CONTEXT_MGR的定义如下所示。

`kernel/drivers/staging/android/binder.h`
```cpp
#define	BINDER_SET_CONTEXT_MGR		_IOW('b', 7, int)
```
它只有一个整型参数，用来描述一个与Service Manager对应的Binder本地对象的地址值。由于与Service Manager对应的Binder本地对象是一个虚拟的对象，并且它的地址值等于0，因此，函数binder_become_context_manager就将IO控制命令BINDER_SET_CONTEXT_MGR的参数设置为0。

Binder驱动程序是在它的函数binder_ioctl中处理IO控制命令BINDER_SET_CONTEXT_MGR的，如下所示。

`kernel/drivers/staging/android/binder.c`
```cpp
01 static struct binder_node *binder_context_mgr_node;
02 static uid_t binder_context_mgr_uid = -1;
03 
04 static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
05 {
06 	int ret;
07 	struct binder_proc *proc = filp->private_data;
08 	struct binder_thread *thread;
09 	unsigned int size = _IOC_SIZE(cmd);
10 	void __user *ubuf = (void __user *)arg;
11 
12     ......
13 
14 	mutex_lock(&binder_lock);
15 	thread = binder_get_thread(proc);
16     ......
17 
18 	switch (cmd) {
19     ......
20 	case BINDER_SET_CONTEXT_MGR:
21 		if (binder_context_mgr_node != NULL) {
22 			printk(KERN_ERR "binder: BINDER_SET_CONTEXT_MGR already set\n");
23 			ret = -EBUSY;
24 			goto err;
25 		}
26 		if (binder_context_mgr_uid != -1) {
27 			if (binder_context_mgr_uid != current->cred->euid) {
28 				printk(KERN_ERR "binder: BINDER_SET_"
29 				       "CONTEXT_MGR bad uid %d != %d\n",
30 				       current->cred->euid,
31 				       binder_context_mgr_uid);
32 				ret = -EPERM;
33 				goto err;
34 			}
35 		} else
36 			binder_context_mgr_uid = current->cred->euid;
37 		binder_context_mgr_node = binder_new_node(proc, NULL, NULL);
38 		if (binder_context_mgr_node == NULL) {
39 			ret = -ENOMEM;
40 			goto err;
41 		}
42 		binder_context_mgr_node->local_weak_refs++;
43 		binder_context_mgr_node->local_strong_refs++;
44 		binder_context_mgr_node->has_strong_ref = 1;
45 		binder_context_mgr_node->has_weak_ref = 1;
46 		break;
47     ......
48 	}
49 	ret = 0;
50 err:
51 	if (thread)
52 		thread->looper &= ~BINDER_LOOPER_STATE_NEED_RETURN;
53 	mutex_unlock(&binder_lock);
54     ......
55 	return ret;
56 }
```
第7行首先获得前面Binder驱动程序为Service Manager进程创建的一个binder_proc结构体，并且保存在变量proc中，接着第15行调用函数binder_get_thread为当前线程创建一个binder_thread结构体。当前线程即为Service Manager进程的主线程，同时它也是Service Manager进程中的一个Binder线程。因此，在它第一次进入到Binder驱动程序时，Binder驱动程序就需要为它创建一个binder_thread结构体。

函数binder_get_thread的实现如下所示。

`kernel/drivers/staging/android/binder.c`
```cpp
01 static struct binder_thread *binder_get_thread(struct binder_proc *proc)
02 {
03 	struct binder_thread *thread = NULL;
04 	struct rb_node *parent = NULL;
05 	struct rb_node **p = &proc->threads.rb_node;
06 
07 	while (*p) {
08 		parent = *p;
09 		thread = rb_entry(parent, struct binder_thread, rb_node);
10 
11 		if (current->pid < thread->pid)
12 			p = &(*p)->rb_left;
13 		else if (current->pid > thread->pid)
14 			p = &(*p)->rb_right;
15 		else
16 			break;
17 	}
18 	if (*p == NULL) {
19 		thread = kzalloc(sizeof(*thread), GFP_KERNEL);
20 		if (thread == NULL)
21 			return NULL;
22 		binder_stats.obj_created[BINDER_STAT_THREAD]++;
23 		thread->proc = proc;
24 		thread->pid = current->pid;
25 		init_waitqueue_head(&thread->wait);
26 		INIT_LIST_HEAD(&thread->todo);
27 		rb_link_node(&thread->rb_node, parent, p);
28 		rb_insert_color(&thread->rb_node, &proc->threads);
29 		thread->looper |= BINDER_LOOPER_STATE_NEED_RETURN;
30 		thread->return_error = BR_OK;
31 		thread->return_error2 = BR_OK;
32 	}
33 	return thread;
34 }
```
函数binder_get_thread在为一个线程创建一个binder_thread结构体之前，首先会检查与该线程所对应的binder_thread结构体是否已经存在。如果存在，就不用创建了，可直接将该binder_thread结构体返回给调用者。

在前面的5.1.1小节中介绍结构体binder_proc时提到，一个进程的所有Binder线程都保存在一个binder_proc结构体的成员变量threads所描述的一个红黑树中。由于这个红黑树是以线程的PID为关键字来组织的，因此，第7行到第17行的while循环就以当前线程的PID在这个红黑树中查找是否已经存在一个对应的binder_thread结构体。如果不存在，即最后得到的红黑树节点p为NULL，那么第19行到第31行代码就为当前线程创建一个binder_thread结构体，并且对它进行初始化，然后再将它添加到其宿主进程的成员变量threads所描述的一个红黑树中。

**注意**
> Binder驱动程序为一个Binder线程创建一个binder_thread结构体时，会将它的状态设置为BINDER_LOOPER_STATE_NEED_RETURN，表示该线程在完成当前操作之后，需要马上返回到用户空间，而不可以去处理进程间的通信请求。

返回到函数binder_ioctl中，全局变量binder_context_mgr_node用来描述与Binder进程间通信机制的上下文管理者相对应的一个Binder实体对象，如果它不等于NULL，即第21行的if语句为true，那么就说明前面已经有组件将自己注册为Binder进程间通信机制的上下文管理者了。由于Binder驱动程序不允许重复注册Binder进程间通信机制的上下文管理者，因此，在这种情况下，它就直接出错返回了。

全局变量binder_context_mgr_uid用来描述注册了Binder进程间通信机制的上下文管理者的进程的有效用户ID，如果它的值不等于-1，即第26行的if语句为true，就说明前面已经有一个进程注册了Binder进程间通信机制的上下文管理者了。在这种情况下，Binder驱动程序就需要检查当前进程的有效用户ID是否等于全局变量binder_context_mgr_uid的值。如果不等于，即第27行的if语句为true，那么它就直接出错返回了。Binder驱动程序允许同一个进程重复使用IO控制命令BINDER_SET_CONTEXT_MGR来注册Binder进程间通信机制的上下文管理者，因为该进程前一次使用IO控制命令BINDER_SET_CONTEXT_MGR时，可能没有成功地将一个组件注册为Binder进程间通信机制的上下文管理者。例如，第37行调用函数binder_new_node创建一个Binder实体对象时，可能会失败。

通过了前面的两个合法性检查之后，第37行就可以调用函数binder_new_node为Service Manager创建一个Binder实体对象了，并将它保存在全局变量binder_context_mgr_node中。函数binder_new_node的实现如下所示。

`kernel/drivers/staging/android/binder.c`
```cpp
01 static struct binder_node *
02 binder_new_node(struct binder_proc *proc, void __user *ptr, void __user *cookie)
03 {
04 	struct rb_node **p = &proc->nodes.rb_node;
05 	struct rb_node *parent = NULL;
06 	struct binder_node *node;
07 
08 	while (*p) {
09 		parent = *p;
10 		node = rb_entry(parent, struct binder_node, rb_node);
11 
12 		if (ptr < node->ptr)
13 			p = &(*p)->rb_left;
14 		else if (ptr > node->ptr)
15 			p = &(*p)->rb_right;
16 		else
17 			return NULL;
18 	}
19 
20 	node = kzalloc(sizeof(*node), GFP_KERNEL);
21 	if (node == NULL)
22 		return NULL;
23 	binder_stats.obj_created[BINDER_STAT_NODE]++;
24 	rb_link_node(&node->rb_node, parent, p);
25 	rb_insert_color(&node->rb_node, &proc->nodes);
26 	node->debug_id = ++binder_last_id;
27 	node->proc = proc;
28 	node->ptr = ptr;
29 	node->cookie = cookie;
30 	node->work.type = BINDER_WORK_NODE;
31 	INIT_LIST_HEAD(&node->work.entry);
32 	INIT_LIST_HEAD(&node->async_todo);
33     ......
34 	return node;
35 }
```
第一个参数proc用来描述Service Manager进程；第二个参数ptr和第三个参数cookie用来描述一个Binder本地对象，它们分别指向该Binder本地对象内部的一个弱引用计数对象的地址值，以及该Binder本地对象的地址值。由于与Service Manager对应的Binder本地对象的地址值为0，因此，第二个参数ptr和第三个参数cookie的值均被指定为NULL。

在前面的5.1.1小节中介绍结构体binder_proc时提到，一个进程的所有Binder实体对象都保存在它的成员变量nodes所描述的一个红黑树中，并且以这些Binder实体对象的成员变量ptr为关键字。同时，在介绍结构体binder_node时又提到，一个Binder实体对象的成员变量ptr指向的是与它对应的Binder本地对象内部的一个弱引用计数对象的地址值，因此，第8行到第18行的while循环就以参数ptr为关键字，在这个红黑树中检查前面是否已经为参数ptr和cookie所描述的Binder本地对象创建过Binder实体对象。如果已经创建过，第17行就直接返回一个NULL值给调用者；否则，第20行到第32行代码就创建一个新的Binder实体对象，并且对它进行初始化，最后将它加入到其宿主进程的成员变量nodes所描述的一个红黑树中。

返回到函数binder_ioctl中，第42行和第43行代码对刚才为Service Manager创建的Binder实体对象binder_context_mgr_node的内部弱引用计数local_weak_refs，以及内部强引用计数local_strong_refs进行初始化，即将它们的值设置为1，避免Binder驱动程序将其释放。接着第44行和第45行又将它的成员变量has_strong_ref和has_weak_ref的值设置为1，表示Binder驱动程序已经请求Service Manager进程增加Service Manager组件的强引用计数和弱引用计数了。由于在系统运行期间，Service Manager组件是一定会存在的，因此，Binder驱动程序实际上不需要请求增加它的引用计数，而是直接将与它对应的Binder实体对象binder_context_mgr_node的成员变量has_strong_ref和has_weak_ref的值设置为1。

至此，Service Manager就成功地将自己注册为Binder进程间通信机制的上下文管理者了。函数binder_ioctl在返回到用户空间之前，第52行会将当前线程的状态位BINDER_LOOPER_STATE_NEED_RETURN清零，这样当该线程下次再进入到Binder驱动程序时，Binder驱动程序就可以将进程间通信请求分发给它处理了。

Service Manager返回到进程的用户空间之后，接着继续调用函数binder_loop来循环等待和处理Client进程的通信请求，即等待和处理Service组件的注册请求，以及其代理对象的获取请求。

### 5.6.3　循环等待Client进程请求
由于Service Manager需要在系统运行期间为Service组件和Client组件提供服务，因此，它就需要通过一个无限循环来等待和处理Service组件和Client组件的进程间通信请求，这是通过调用函数binder_loop来实现的，如下所示。

`frameworks/base/cmds/servicemanager/binder.c`
```cpp
01 void binder_loop(struct binder_state *bs, binder_handler func)
02 {
03     int res;
04     struct binder_write_read bwr;
05     unsigned readbuf[32];
06 
07     bwr.write_size = 0;
08     bwr.write_consumed = 0;
09     bwr.write_buffer = 0;
10     
11     readbuf[0] = BC_ENTER_LOOPER;
12     binder_write(bs, readbuf, sizeof(unsigned));
13 
14     for (;;) {
15         bwr.read_size = sizeof(readbuf);
16         bwr.read_consumed = 0;
17         bwr.read_buffer = (unsigned) readbuf;
18 
19         res = ioctl(bs->fd, BINDER_WRITE_READ, &bwr);
20 
21         if (res < 0) {
22             LOGE("binder_loop: ioctl failed (%s)\n", strerror(errno));
23             break;
24         }
25 
26         res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);
27         if (res == 0) {
28             LOGE("binder_loop: unexpected reply?!\n");
29             break;
30         }
31         if (res < 0) {
32             LOGE("binder_loop: io error %d %s\n", res, strerror(errno));
33             break;
34         }
35     }
36 }
```
从前面的调用过程可以知道，第一个参数bs指向前面在函数binder_open中创建的一个binder_state结构体；第二个参数func指向Service Manager中的函数svcmgr_handler，它是用来处理Service组件和Client组件的进程间通信请求的。

在前面的5.1.1小节中介绍Binder命令协议BinderDriverCommandProtocol时提到，一个线程要通过协议BC_ENTER_LOOPER或者BC_REGISTER_LOOPER将自己注册为Binder线程，以便Binder驱动程序可以将进程间通信请求分发给它处理。由于Service Manager进程的主线程是主动成为一个Binder线程的，因此，它就使用BC_ENTER_LOOPER协议将自己注册到Binder驱动程序中。

第11行首先将BC_ENTER_LOOPER协议代码写入到缓冲区readbuf中，接着第12行调用函数binder_write将它发送到Binder驱动程序中。函数binder_write的实现如下所示。

`frameworks/base/cmds/servicemanager/binder.c`
```cpp
01 int binder_write(struct binder_state *bs, void *data, unsigned len)
02 {
03     struct binder_write_read bwr;
04     int res;
05     bwr.write_size = len;
06     bwr.write_consumed = 0;
07     bwr.write_buffer = (unsigned) data;
08     bwr.read_size = 0;
09     bwr.read_consumed = 0;
10     bwr.read_buffer = 0;
11     res = ioctl(bs->fd, BINDER_WRITE_READ, &bwr);
12     if (res < 0) {
13         fprintf(stderr,"binder_write: ioctl failed (%s)\n",
14                 strerror(errno));
15     }
16     return res;
17 }
```
由于BC_ENTER_LOOPER协议是通过IO控制命令BINDER_WRITE_READ发送到Binder驱动程序中的，而IO控制命令BINDER_WRITE_READ后面跟的参数是一个binder_write_read结构体，因此，第3行首先定义一个binder_write_read结构体bwr，接着第7行将参数data所指向的一块缓冲区作为它的输入缓冲区。第8行到第10行代码将binder_write_read结构体bwr的输出缓冲区设置为空，这样，当前线程将自己注册到Binder驱动程序中之后，就会马上返回到用户空间，而不会在Binder驱动程序中等待Client进程的通信请求。由于参数data所指向的一块缓冲区的内容已经被设置为BC_ENTER_LOOPER协议代码，因此，接下来第11行就可以调用函数ioctl将当前线程注册到Binder驱动程序中了。

IO控制命令BINDER_WRITE_READ是由Binder驱动程序中的函数binder_ioctl负责处理的，如下所示。

`kernel/drivers/staging/android/binder.c`
```cpp
01 static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
02 {
03 	int ret;
04 	struct binder_proc *proc = filp->private_data;
05 	struct binder_thread *thread;
06 	unsigned int size = _IOC_SIZE(cmd);
07 	void __user *ubuf = (void __user *)arg;
08 
09     ......
10 
11 	mutex_lock(&binder_lock);
12 	thread = binder_get_thread(proc);
13     ......
14 
15 	switch (cmd) {
16 	case BINDER_WRITE_READ: {
17 		struct binder_write_read bwr;
18 		if (size != sizeof(struct binder_write_read)) {
19 			ret = -EINVAL;
20 			goto err;
21 		}
22 		if (copy_from_user(&bwr, ubuf, sizeof(bwr))) {
23 			ret = -EFAULT;
24 			goto err;
25 		}
26         ......
27 		if (bwr.write_size > 0) {
28 			ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &bwr.write_consumed);
29             ......
30 		}
31 		if (bwr.read_size > 0) {
32 			ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &bwr.read_consumed, filp->f_flags & O_NONBLOCK);
33 			if (!list_empty(&proc->todo))
34 				wake_up_interruptible(&proc->wait);
35             ......
36 		}
37         ......
38 		if (copy_to_user(ubuf, &bwr, sizeof(bwr))) {
39 			ret = -EFAULT;
40 			goto err;
41 		}
42 		break;
43 	}
44     ......
45 	}
46 	ret = 0;
47 err:
48     ......
49 	return ret;
50 }
```
第12行调用函数binder_get_thread来获取与当前线程对应的一个binder_thread结构体，并保存在变量thread中。当前线程即为Service Manager进程的主线程，前面它将Service Manager注册为Binder进程间通信机制的上下文管理者时，Binder驱动程序已经为它创建过一个binder_thread结构体了，因此，第12行调用函数binder_get_thread时，就可以直接获得该binder_thread结构体。

第22行将从用户空间传进来的一个binder_write_read结构体拷贝出来，并且保存在变量bwr中。该结构体的输入缓冲区长度大于0，而输出缓冲区长度等于0，即第27行的if语为true，而第31行的if语句为false，因此，接下来第28行调用函数binder_thread_write处理完成BC_ENTER_LOOPER协议之后，就返回到用户空间了。

函数binder_thread_write处理BC_ENTER_LOOPER协议的相关代码如下所示。

`kernel/drivers/staging/android/binder.c`
```cpp
01 int
02 binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
03 		    void __user *buffer, int size, signed long *consumed)
04 {
05 	uint32_t cmd;
06 	void __user *ptr = buffer + *consumed;
07 	void __user *end = buffer + size;
08 
09 	while (ptr < end && thread->return_error == BR_OK) {
10 		if (get_user(cmd, (uint32_t __user *)ptr))
11 			return -EFAULT;
12 		ptr += sizeof(uint32_t);
13         ......
14 		switch (cmd) {
15         ......
16 		case BC_ENTER_LOOPER:
17             ......
18 			if (thread->looper & BINDER_LOOPER_STATE_REGISTERED) {
19 				thread->looper |= BINDER_LOOPER_STATE_INVALID;
20 				binder_user_error("binder: %d:%d ERROR:"
21 					" BC_ENTER_LOOPER called after "
22 					"BC_REGISTER_LOOPER\n",
23 					proc->pid, thread->pid);
24 			}
25 			thread->looper |= BINDER_LOOPER_STATE_ENTERED;
26 			break;
27         ......
28 		}
29 		*consumed = ptr - buffer;
30 	}
31 	return 0;
32 }
```
它主要是将目标线程thread的状态设置为BINDER_LOOPER_STATE_ENTERED，以表明该线程是一个Binder线程，可以处理进程间通信请求。

**注意**
> 线程状态BINDER_LOOPER_STATE_REGISTERED和BINDER_LOOPER_STATE_ENTERED是互斥的，因此，第25行将线程状态设置为BINDER_LOOPER_STATE_ENTERED之前，第18行首先会检查该线程的状态是否已经为BINDER_LOOPER_STATE_REGISTERED。

函数binder_thread_write处理完成BC_ENTER_LOOPER协议之后，就返回到函数binder_ioctl中，后者接着又返回到用户空间中，即Service Manager进程的函数binder_write中，最后返回到函数binder_loop中。

在函数binder_loop中，第14行到第35行的循环不断使用IO控制命令BINDER_WRITE_READ来检查Binder驱动程序是否有新的进程间通信请求需要它来处理。如果有，就将它们交给函数binder_parse来处理；否则，当前线程就会在Binder驱动程序中睡眠等待，直到有新的进程间通信请求到来为止。

**注意**
> 在for循环中，每一次通过IO控制命令BINDER_WRITE_READ进入到Binder驱动程序时，所传递的binder_write_read结构体中的输入缓冲区的长度均为0，而输出缓冲区的长度等于缓冲区readbuf的大小，即128个字节。由于该binder_write_read结构体中的输入缓冲区的长度为0，因此，Binder驱动程序的函数binder_ioctl在处理这些IO控制命令BINDER_WRITE_READ时，只会调用函数binder_thread_read来检查Service Manager进程是否有新的进程间通信请求需要处理。

Binder驱动程序的函数binder_thread_read的实现如下所示。

`kernel/drivers/staging/android/binder.c`
```cpp
01 static int
02 binder_thread_read(struct binder_proc *proc, struct binder_thread *thread,
03 	void  __user *buffer, int size, signed long *consumed, int non_block)
04 {
05 	void __user *ptr = buffer + *consumed;
06 	void __user *end = buffer + size;
07 
08 	int ret = 0;
09 	int wait_for_proc_work;
10 
11     ......
12 
13 retry:
14 	wait_for_proc_work = thread->transaction_stack == NULL && list_empty(&thread->todo);
15 
16     ......
17 
18 	thread->looper |= BINDER_LOOPER_STATE_WAITING;
19 	if (wait_for_proc_work)
20 		proc->ready_threads++;
21 	mutex_unlock(&binder_lock);
22 	if (wait_for_proc_work) {
23         ......
24 		binder_set_nice(proc->default_priority);
25 		if (non_block) {
26 			if (!binder_has_proc_work(proc, thread))
27 				ret = -EAGAIN;
28 		} else
29 			ret = wait_event_interruptible_exclusive(proc->wait, binder_has_proc_work(proc, thread));
30 	} else {
31 		if (non_block) {
32 			if (!binder_has_thread_work(thread))
33 				ret = -EAGAIN;
34 		} else
35 			ret = wait_event_interruptible(thread->wait, binder_has_thread_work(thread));
36 	}
37 	mutex_lock(&binder_lock);
38 	if (wait_for_proc_work)
39 		proc->ready_threads--;
40 	thread->looper &= ~BINDER_LOOPER_STATE_WAITING;
41     
42     ......
43 
44 	while (1) {
45         ......
46 	}
47 
48 done:
49 
50 	*consumed = ptr - buffer;
51 	if (proc->requested_threads + proc->ready_threads == 0 &&
52 	    proc->requested_threads_started < proc->max_threads &&
53 	    (thread->looper & (BINDER_LOOPER_STATE_REGISTERED |
54 	     BINDER_LOOPER_STATE_ENTERED)) /* the user-space code fails to */
55 	     /*spawn a new thread if we leave this out */) {
56 		proc->requested_threads++;
57         ......
58 		if (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))
59 			return -EFAULT;
60 	}
61 	return 0;
62 }
```
在前面的5.1.1小节中介绍结构体binder_thread和binder_transaction时提到，如果一个线程的事务堆栈transaction_stack不等于NULL，就表示它正在等待其他线程完成另外一个事务。另外，如果一个线程的todo队列不为空，就说明该线程有未处理的工作项。一个线程只有在其事务堆栈transaction_stack为NULL，并且其todo队列为空时，才可以去处理其所属进程的todo队列中的待处理工作项；否则，它就要处理其事务堆栈transaction_stack中的事务或者todo队列中的待处理工作项。

第14行检查当前线程的事务堆栈transaction_stack是否为NULL，以及todo队列是否为空。如果两个条件都成立，那么就会将变量wait_for_proc_work的值设置为1，表示它接下来要检查它所属进程的todo队列中是否有未处理的工作项；否则，它接下来就要优先处理自己的事务或者工作项了。在继续往下执行之前，第18行首先将当前线程的状态设置为BINDER_LOOPER_STATE_WAITING，表示该线程正处于空闲状态，接着第19行判断变量wait_for_proc_work的值是否等于1。如果是，那么就说明当前线程所属的进程又多了一个空闲Binder线程，因此，第20行就将该进程的空闲Binder线程数ready_threads加1。接下来如果Binder驱动程序发现当前线程有新的工作项需要处理时，第40行就会将它的状态位BINDER_LOOPER_STATE_WAITING清空，并且根据变量wait_for_proc_work的值是否等于1，来决定是否需要减少它所属进程的空闲Binder线程数ready_threads，如第38行和第39行代码所示。

假设变量wait_for_proc_work的值等于1，即第22行的if语句为true，就说明当前线程需要检查它所属进程的todo队列中是否有未处理的工作项。在检查之前，第24行首先调用函数binder_set_nice把当前线程的优先级设置为它所属进程的优先级，这是因为如果它所属的进程有未处理的工作项，它就需要代表该进程去处理这个工作项。参数non_block表示当前线程是否以非阻塞模式打开设备文件/dev/binder。如果是，就表示当前线程不可以在Binder驱动程序中睡眠，即如果当前线程发现其所属进程的todo队列为空时，它不可以进入睡眠状态去等待该进程有新的未处理工作项，如第26行和第27行代码所示；否则，当前线程就会调用函数wait_event_interruptible_exclusive来睡眠等待直到其所属的进程有新的未处理工作项为止，如第29行代码所示。

判断一个进程是否有未处理的工作项是通过函数binder_has_proc_work来实现的，它的定义如下所示。

`kernel/drivers/staging/android/binder.c`
```cpp
1 static int
2 binder_has_proc_work(struct binder_proc *proc, struct binder_thread *thread)
3 {
4 	return !list_empty(&proc->todo) || (thread->looper & BINDER_LOOPER_STATE_NEED_RETURN);
5 }
```
如果一个进程的todo队列不为空，那么就说明它有未处理的工作项，因此，函数的返回值就等于1。另外，如果当前线程的状态被设置为BINDER_LOOPER_STATE_NEED_RETURN，那么就表示当前线程需要马上返回到用户空间，因此，这时候函数的返回值也会等于1，防止当前线程进入睡眠等待状态。

返回到函数binder_thread_read中，假设变量wait_for_proc_work的值等于0，即第22行的if语句为false，那么就说明当前线程需要检查的是自己的todo队列中是否有未处理的工作项。同样，当前线程检查参数non_block的值是否等于1，如果是，那么当它发现自己的todo队列为空时，它就要马上返回到用户空间，如第32行和第33行代码所示；否则，它就要调用函数wait_event_interruptible_exclusive来睡眠等待直到它有新的未处理工作项为止，如第35行代码所示。

判断一个线程是否有未处理的工作项是通过函数binder_has_thread_work来实现的，它的定义如下所示。

`kernel/drivers/staging/android/binder.c`
```cpp
1 static int
2 binder_has_thread_work(struct binder_thread *thread)
3 {
4 	return !list_empty(&thread->todo) || thread->return_error != BR_OK ||
5 		(thread->looper & BINDER_LOOPER_STATE_NEED_RETURN);
6 }
```
如果一个线程的todo队列不为空，那么就说明它有未处理的工作项，因此，函数的返回值就等于1。另外，如果该线程的状态被设置为BINDER_LOOPER_STATE_NEED_RETURN，那么就表示它需要马上返回到用户空间，因此，这时候函数的返回值也会等于1，防止它进入睡眠等待状态。还有另外一种情况也需要该线程马上返回到用户空间，即它上次在Binder驱动程序中处理某一个工作项时出现了错误，这时候Binder驱动程序就会将相应的错误代码（不等于BR_OK）设置到对应的binder_thread结构体的成员变量return_error中。因此，在这种情况下，函数的返回值也会等于1，防止它进入睡眠等待状态。
返回到函数binder_thread_read中，假设当前线程没有新的工作项需要处理，那么它要么睡眠在它所属进程的一个等待队列wait中，要么睡眠在自己的一个等待队列wait中，直到其他线程将它唤醒为止。
当前线程被唤醒之后，它就会调用第44行到第46行的while循环来处理它的工作项。处理完成之后，在返回到函数binder_ioctl之前，第51行到第60行代码还会检查是否需要请求当前线程所属的进程proc增加一个新的Binder线程来处理进程间通信请求。如果满足以下4个条件：

- 进程proc的空闲线程数ready_threads等于0；
- Binder驱动程序当前不是正在请求进程proc增加一个新的Binder线程，即它的成员变量requested_threads的值等于0；
- Binder驱动程序请求进程proc增加的Binder线程数requested_threads_started小于预设的最大数max_threads。
- 当前线程是一个已经注册了的Binder线程，即它的状态为BINDER_LOOPER_STATE_REGISTERED或者BINDER_LOOPER_STATE_ENTERED；

那么第58行就会将一个返回协议代码BR_SPAWN_LOOPER写入到用户空间缓冲区buffer中，以便进程proc可以创建一个新的线程加入到它的Binder线程池中。前面三个条件都比较容易理解，第4个条件是什么意思呢？如果当前线程不是一个Binder线程，那么它是不会去处理返回协议BR_SPAWN_LOOPER的，因此，这时候就不应该通过它来请求进程proc增加一个新的Binder线程。另一个需要注意的地方是，当Binder驱动程序请求进程proc增加一个新的Binder线程时，会将进程proc的成员变量requested_threads的值增加1，用来约束第2个条件，目的是避免同时请求进程proc增加多个Binder线程。当进程proc新增加的Binder线程注册到Binder驱动程序之后，Binder驱动程序就会将它的成员变量requested_threads的值减少1。

至此，Service Manager的启动过程就分析完成了。为了方便接下来内容的描述，我们假设Service Manager进程的主线程没有待处理的工作项，因此，它就睡眠在Binder驱动程序的函数inder_thread_read中，等待其他进程的Service组件或者Client组件向它发送进程间通信请求。

此外，从Service Manager的启动过程可以知道，当一个进程使用IO控制命令BINDER_WRITE_READ与Binder驱动程序交互时：
- 如果传递给Binder驱动程序的binder_write_read结构体的输入缓冲区的长度大于0，那么Binder驱动程序就会调用函数binder_thread_write来处理输入缓冲区中的命令协议；
- 如果传递给Binder驱动程序的binder_write_read结构体的输出缓冲区的长度大于0，那么Binder驱动程序就会调用函数binder_thread_read将进程需要处理的工作项写入到该输出缓冲区中，即将相应的返回协议写入到该输出缓冲区中，以便进程可以在用户空间处理。
- 
在本章接下来的内容中，为了避免重复描述，当进程传递给Binder驱动程序的binder_write_read结构体的输入缓冲区的长度大于0时，我们就直接进入到函数binder_thread_write中分析输入缓冲区中的命令协议的处理过程。同样，当进程传递给Binder驱动程序的binder_write_read结构体的输出缓冲区的长度大于0时，我们就直接进入到函数binder_thread_read中分析Binder驱动程序是如何将一个工作项，即一个进程间通信请求写入到输出缓冲区中的，以便进程返回到用户空间之后可以对它进行相应的处理。

