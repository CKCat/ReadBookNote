
## 5.2　Binder进程间通信库
Android系统在应用程序框架层中将各种Binder驱动程序操作封装成一个Binder库，这样进程就可以方便地调用Binder库提供的接口来实现进程间通信。在本节中，我们将学习Binder库的基础知识，以便加深对Binder驱动程序的理解。在接下来的5.3小节中，我们将使用Binder库创建一个进程间通信应用实例。

在Binder库中，Service组件和Client组件分别使用模板类BnInterface和BpInterface来描述，其中，前者称为Binder本地对象，后者称为Binder代理对象。Binder库中的Binder本地对象和Binder代理对象分别对应于Binder驱动程序中的Binder实体对象和Binder引用对象。下面我们就主要介绍这两个模板类的实现。

模板类BnInterface和BpInterface的定义如下所示。

`frameworks/base/include/binder/IInterface.h`
```cpp
01 template<typename INTERFACE>
02 class BnInterface : public INTERFACE, public BBinder
03 {
04 public:
05     virtual sp<IInterface>      queryLocalInterface(const String16& _descriptor);
06     virtual const String16&     getInterfaceDescriptor() const;
07 
08 protected:
09     virtual IBinder*            onAsBinder();
10 };
11 
12 template<typename INTERFACE>
13 class BpInterface : public INTERFACE, public BpRefBase
14 {
15 public:
16                                 BpInterface(const sp<IBinder>& remote);
17 
18 protected:
19     virtual IBinder*            onAsBinder();
20 };
```
模板参数INTERFACE是一个由进程自定义的Service组件接口，模板类BnInterface和BpInterface都需要实现该接口。在使用Binder库开发Service组件和Client组件时，除了要定义Service组件接口之外，还必须要实现一个Binder本地对象类和一个Binder代理对象类，它们分别继承于模板类BnInterface和BpInterface。例如，在接下来的5.3小节要介绍的Binder进程间通信应用实例中，我们首先定义一个硬件访问服务接口IFregService，用来访问第2章介绍的虚拟硬件设备freg的寄存器val的值；然后又自定义一个Binder本地对象类BnFregService和一个Binder代理对象类BpFregService，它们分别继承于模板类BnInterface和BpInterface，并且实现了IFregService接口。

模板类BnInterface继承了BBinder类，后者为Binder本地对象提供了抽象的进程间通信接口，它的定义如下所示。

`frameworks/base/include/binder/Binder.h`
```cpp
class BBinder : public IBinder
{
public:
    ......
    
    virtual status_t    transact(   uint32_t code,
                                    const Parcel& data,
                                    Parcel* reply,
                                    uint32_t flags = 0);
    ......

protected:
    ......

    virtual status_t    onTransact( uint32_t code,
                                    const Parcel& data,
                                    Parcel* reply,
                                    uint32_t flags = 0);
    ......
};
```
BBinder类有两个重要的成员函数transact和onTransact。当一个Binder代理对象通过Binder驱动程序向一个Binder本地对象发出一个进程间通信请求时，Binder驱动程序就会调用该Binder本地对象的成员函数transact来处理该请求。成员函数onTransact是由BBinder的子类，即Binder本地对象类来实现的，它负责分发与业务相关的进程间通信请求。事实上，与业务相关的进程间通信请求是由Binder本地对象类的子类，即Service组件类来负责处理的。例如，在接下来的5.3小节将要介绍的Binder进程间通信应用实例中，Binder本地对象类BnFregService重写了父类BBinder的成员函数onTransact，并且将访问虚拟硬件设备freg的寄存器val的操作分发给其子类FregService来处理。

BBinder类又继承了IBinder类，而后者又继承了RefBase类。从第3章的内容可以知道，继承了RefBase类的子类的对象均可以通过强指针和弱指针来维护它们的生命周期，换句话说，就是Binder本地对象是通过引用计数技术来维护生命周期的。由于Binder本地对象受到Binder驱动程序中的Binder实体对象，以及运行在Client进程中的Binder代理对象引用，因此，它的引用计数技术比较复杂，在后面的5.4小节中，我们再详细分析。

模板类BpInterface继承了BpRefBase类，后者为Binder代理对象提供了抽象的进程间通信接口，它的定义如下所示。

`frameworks/base/include/binder/Binder.h`
```cpp
class BpRefBase : public virtual RefBase
{
protected:
                            BpRefBase(const sp<IBinder>& o);
    ......

    inline  IBinder*        remote()                { return mRemote; }
    inline  IBinder*        remote() const          { return mRemote; }

private:
    ......

    IBinder* const          mRemote;
    ......
};
```
BpRefBase类又继承了RefBase类，因此，它的子类对象，即Binder代理对象也可以通过强指针和弱指针来维护生命周期。同样，在后面的5.4小节中，我们再详细分析Binder代理对象的生命周期。

BpRefBase类有一个重要的成员变量mRemote，它指向一个BpBinder对象，可以通过成员函数remote来获取。BpBinder类实现了BpRefBase类的进程间通信接口，它的定义如下所示。

`frameworks/base/include/binder/BpBinder.h`
```cpp
class BpBinder : public IBinder
{
public:
                        BpBinder(int32_t handle);

    inline  int32_t     handle() const { return mHandle; }

    ......
    
    virtual status_t    transact(   uint32_t code,
                                    const Parcel& data,
                                    Parcel* reply,
                                    uint32_t flags = 0);

    ......

private:
    const   int32_t             mHandle;
    ......
};

```
BpBinder类的成员变量mHandle是一个整数，它表示一个Client组件的句柄值，可以通过成员函数handle来获取。在前面的5.1.1小节中介绍结构体binder_ref时提到，每一个Client组件在Binder驱动程序中都对应有一个Binder引用对象，而每一个Binder引用对象都有一个句柄值，其中，Client组件就是通过这个句柄值来和Binder驱动程序中的Binder引用对象建立对应关系的。

BpBinder类的成员函数transact用来向运行在Server进程中的Service组件发送进程间通信请求，这是通过Binder驱动程序间接实现的。BpBinder类的成员函数transact会把BpBinder类的成员变量mHandle，以及进程间通信数据发送给Binder驱动程序，这样Binder驱动程序就能够根据这个句柄值来找到对应的Binder引用对象，继而找到对应的Binder实体对象，最后就可以将进程间通信数据发送给对应的Service组件了。

无论是BBinder类，还是BpBinder类，它们都是通过IPCThreadState类来和Binder驱动程序交互的。IPCThreadState类的定义如下所示。

`frameworks/base/include/binder/IPCThreadState.h`
```cpp
class IPCThreadState
{
public:
    static  IPCThreadState*     self();
    
    ......
            
            status_t            transact(int32_t handle,
                                         uint32_t code, const Parcel& data,
                                         Parcel* reply, uint32_t flags);
    ......
    
private:
    ......
            status_t            talkWithDriver(bool doReceive=true);
    ......
    
    const   sp<ProcessState>    mProcess;
    ......
};

```
在前面的5.1.1小节中介绍结构体binder_proc时提到，每一个使用了Binder进程间通信机制的进程都有一个Binder线程池，用来处理进程间通信请求。对于每一个Binder线程来说，它的内部都有一个IPCThreadState对象，我们可以通过IPCThreadState类的静态成员函数self来获取，并且调用它的成员函数transanct来和Binder驱动程序交互。在IPCThreadState类的成员函数transanct内部，与Binder驱动程序的交互操作又是通过调用成员函数talkWithDriver来实现的，它一方面负责向Binder驱动程序发送进程间通信请求，另一方面又负责接收来自Binder驱动程序的进程间通信请求。

IPCThreadState类有一个成员变量mProcess，它指向一个ProcessState对象。对于每一个使用了Binder进程间通信机制的进程来说，它的内部都有一个ProcessState对象，它负责初始化Binder设备，即打开设备文件/dev/binder，以及将设备文件/dev/binder映射到进程的地址空间。由于这个ProcessState对象在进程范围内是唯一的，因此，Binder线程池中的每一个线程都可以通过它来和Binder驱动程序建立连接。

ProcessState类的定义如下所示。

`frameworks/base/include/binder/ProcessState.h`
```cpp
class ProcessState : public virtual RefBase
{
public:
    static  sp<ProcessState>    self();
    ......
private:
    ......
            int                 mDriverFD;
            void*               mVMStart;
    ......
};
```
进程中的ProcessState对象可以通过ProcessState类的静态成员函数self来获取。第一次调用ProcessState类的静态成员函数self时，Binder库就会为进程创建一个ProcessState对象，并且调用函数open来打开设备文件/dev/binder，接着又调用函数mmap将它映射到进程的地址空间，即请求Binder驱动程序为进程分配内核缓冲区。设备文件/dev/binder映射到进程的地址空间后，得到的内核缓冲区的用户地址就保存在其成员变量mVMStart中。

至此，Binder库的基础知识就介绍完了。下面我们通过图5-15和图5-16来总结Service组件和Client组件的实现原理。

![图5-15　Service组件的实现原理](2020-12-07-18-15-47.png)

![图5-16　Client组件的实现原理](2020-12-07-18-16-56.png)

在图5-15和图5-16中，IXXXXXX表示Service组件和Client组件都要实现的服务接口；BnXXXXXX、BpXXXXXX分别表示Service组件和Client组件要继承的Binder本地对象类和Binder代理对象类；XXXXXX表示一个Service组件。在接下来的5.3小节要介绍的Binder进程间通信应用实例中，这四个类就分别为IFregService、BnFregService、BpFregService和FregService。实现了这四个类，我们就可以使用Binder库来实现进程间通信了。

