
<!-- TOC -->

- [4.6 `Logcat` 工具分析](#46-logcat-工具分析)
    - [4.6.1　基础数据结构](#461　基础数据结构)
        - [struct logger_entry](#struct-logger_entry)
        - [struct queued_entry_t](#struct-queued_entry_t)
        - [log_device_t](#log_device_t)
        - [enum android_LogPriority](#enum-android_logpriority)
        - [enum AndroidLogPrintFormat](#enum-androidlogprintformat)
        - [enum AndroidLogEntry_t](#enum-androidlogentry_t)
        - [enum FilterInfo_t](#enum-filterinfo_t)
        - [enum AndroidLogFormat_t](#enum-androidlogformat_t)
        - [enum EventTag](#enum-eventtag)
        - [enum EventTagMap](#enum-eventtagmap)
    - [4.6.2　初始化过程](#462　初始化过程)
    - [4.6.3　日志记录的读取过程](#463　日志记录的读取过程)
    - [4.6.4　日志记录的输出过程](#464　日志记录的输出过程)

<!-- /TOC -->

## 4.6 `Logcat` 工具分析
将日志记录写入到 `Logger` 日志驱动程序的目的是要将它们记录起来，等到合适的时候再将它们读取和显示出来，从而帮助我们分析程序的行为。在本节中，我们将通过分析日志查看工具 `Logcat` 的实现来学习日志记录的读取过程。

`Logcat` 是内置在 `Android` 系统中的一个实用工具，可以在主机上执行 `adb logcat` 命令来查看目标设备上的日志记录。例如，首先执行 `emulator` 将 `Android` 模拟器启动起来，然后执行 `adb logcat` 命令激活 `Android` 模拟器中的 `Logcat` 工具。

```bash
emulator &
adb logcat
```
最后就可以不断地看到 `Android` 模拟器中的日志记录输出了。

`Logcat` 工具的用法很丰富，但是本节并不打算详细介绍它的使用方法。如果读者想进一步了解它的用法，可以在 `Android` 模拟器启动之后，执行以下命令来获得帮助。

```bash
adb logcat --help
```

`Logcat` 工具主要涉及的源代码文件的位置如下 : 

```bash
~Android/system/core
---- include
    ---- cutils
        ---- logprint.h
        ---- event_tag_map.h
        ---- logger.h
    ---- android
        ---- log.h
---- liblog
    ---- logprint.c
    ---- event_tag_map.c
---- logcat
    ---- logcat.cpp
```
其中，文件 `logger.h` 和 `log.h` 定义了一些基础数据结构和宏；文件 `logprint.h` 、 `event_tag_map.h` 、 `logprint.c` 和 `event_tag_map.c` 实现在日志库 `liblog` 中，它们主要用来处理日志记录的输出；文件 `logcat.cpp` 是 `Logcat` 工具的源代码实现。

我们首先介绍 `Logcat` 工具的基础数据结构，然后分析使用 `Logcat` 工具读取和显示 `Logger` 日志驱动程序中的日志记录的过程，主要包括三个情景，分别是工具初始化过程、日志记录的读取和输出过程。

### 4.6.1　基础数据结构

#### struct logger_entry

`system/core/include/cutils/logger.h`
```c
struct logger_entry {
	__u16		len;	/* length of the payload */
	__u16		__pad;	/* no matter what, we get 2 bytes of padding */
	__s32		pid;	/* generating process's pid */
	__s32		tid;	/* generating process's tid */
	__s32		sec;	/* seconds since Epoch */
	__s32		nsec;	/* nanoseconds */
	char		msg[0];	/* the entry's payload */
};

#define LOGGER_ENTRY_MAX_LEN		(4*1024)
#define LOGGER_ENTRY_MAX_PAYLOAD	\
	(LOGGER_ENTRY_MAX_LEN - sizeof(struct logger_entry))
```
结构体 `logger_entry` 和宏 `LOGGER_ENTRY_MAX_LEN` 、 `LOGGER_ENTRY_MAX_PAYLOAD` 是从 `Logger` 日志驱动程序中提取出来的。在前面的 `4.2.1` 小节中，我们已经分析过它们的实现了。其中，结构体 `logger_entry` 用来描述一条日志记录；宏 `LOGGER_ENTRY_MAX_LEN` 用来描述一条日志记录的最大长度，包括日志记录头和日志记录有效负载两部分内容的长度；宏 `LOGGER_ENTRY_MAX_PAYLOAD` 用来描述日志记录有效负载的最大长度。

#### struct queued_entry_t 
`system/core/logcat/logcat.cpp`
```cpp
struct queued_entry_t {
    union {
        unsigned char buf[LOGGER_ENTRY_MAX_LEN + 1] __attribute__((aligned(4)));
        struct logger_entry entry __attribute__((aligned(4)));
    };
    queued_entry_t* next;

    queued_entry_t() {
        next = NULL;
    }
};
```
结构体 `queued_entry_t` 用来描述一个日志记录队列。每一种类型的日志记录都对应有一个日志记录队列。 `Logcat` 工具将相同类型的日志记录按照写入时间的先后顺序保存在同一个队列中，这样在输出日志记录时，沿着这个队列就可以按照时间顺序来依次输出系统中的日志信息了。结构体 `queued_entry_t` 的第一个成员变量是一个联合体，用来描述一条日志记录的内容。通过这个联合体， `Logcat` 工具就既可以把一条日志记录内容当作一个缓冲区来处理，也可以把它当作一个 `logger_entry` 结构体来处理。结构体 `queued_entry_t` 的另外一个成员变量 `next` 用来连接下一条日志记录，从而形成一个队列。

#### log_device_t

`system/core/logcat/logcat.cpp`
```cpp
struct log_device_t {
    char* device;
    bool binary;
    int fd;
    bool printed;
    char label;

    queued_entry_t* queue;
    log_device_t* next;

    log_device_t(char* d, bool b, char l) {
        device = d;
        binary = b;
        label = l;
        queue = NULL;
        next = NULL;
        printed = false;
    }

    void enqueue(queued_entry_t* entry) {
        if (this->queue == NULL) {
            this->queue = entry;
        } else {
            queued_entry_t** e = &this->queue;
            while (*e && cmp(entry, *e) >= 0) {
                e = &((*e)->next);
            }
            entry->next = *e;
            *e = entry;
        }
    }
};
```
结构体 `log_device_t` 用来描述一个日志设备。成员变量 `device` 保存的是日志设备文件名称。我们知道， `Logger` 日志驱动程序在初始化时，会创建四个设备文件 `/dev/log/main` 、 `/dev/log/system` 、 `/dev/log/radio` 和 `/dev/log/events` ，分别用来代表四个日志设备。成员变量label用来描述日志设备的标号，其中，日志设备`/dev/log/main`、 `/dev/log/system` 、 `/dev/log/radio` 和 `/dev/log/events` 对应的标号分别为 `m` 、 `s` 、 `r` 和 `e` 。成员变量 `binary` 是一个布尔值，表示日志记录的内容是否是二进制格式的。我们知道，只有日志设备 `/dev/log/events` 的日志记录内容才是二进制格式的，其余的日志设备的日志记录内容均为文本格式的。成员变量 `fd` 是一个文件描述符，它是通过调用函数 `open` 来打开相应的日志设备文件得到的，用来从 `Logger` 日志驱动程序中读取日志记录。成员变量 `printed` 是一个布尔值，用来表示一个日志设备是否已经处于输出状态。成员变量 `queue` 用来保存日志设备中的日志记录。成员变量 `next` 用来连接下一个日志设备，这样， `Logcat` 工具就可以把所有已经打开的日志设备保存在一个队列中。

结构体 `log_device_t` 的成员函数 `enqueue` 用来将一条日志记录添加到内部的日志记录队列中。每次往队列中加入一条日志记录时，都会根据它的写入时间来找到它在队列中的位置，然后再将它插入到队列中。两条日志记录的写入时间比较是通过调用函数 `cmp` 来实现的，它的定义如下所示。

`system/core/logcat/logcat.cpp`
```cpp
static int cmp(queued_entry_t* a, queued_entry_t* b) {
    int n = a->entry.sec - b->entry.sec;
    if (n != 0) {
        return n;
    }
    return a->entry.nsec - b->entry.nsec;
}
```
它先比较日志写入时间的秒数。如果相等，再比较日志写入时间的毫秒数；否则，就可以得到比较结果。如果函数 `cmp` 的返回值大于 `0` ，就表示日志记录 `a` 的写入时间比日志记录b晚；如果函数 `cmp` 的返回值等于 `0` ，就表示日志记录 `a` 和 `b` 的写入时间相等；如果函数 `cmp` 的返回值小于 `0` ，就表示日志记录 `a` 的写入时间比日志记录 `b` 早。

#### enum android_LogPriority

`system/core/include/android/log.h`
```cpp
/*
 * Android log priority values, in ascending priority order.
 */
typedef enum android_LogPriority {
    ANDROID_LOG_UNKNOWN = 0,
    ANDROID_LOG_DEFAULT,    /* only for SetMinPriority() */
    ANDROID_LOG_VERBOSE,
    ANDROID_LOG_DEBUG,
    ANDROID_LOG_INFO,
    ANDROID_LOG_WARN,
    ANDROID_LOG_ERROR,
    ANDROID_LOG_FATAL,
    ANDROID_LOG_SILENT,     /* only for SetMinPriority(); must be last */
} android_LogPriority;
```
枚举 `android_LogPriority` 用来描述日志记录的优先级，它一共有九个值，分别表示九个优先级。

#### enum AndroidLogPrintFormat
`system/core/include/cutils/logprint.h`
```cpp
typedef enum {
    FORMAT_OFF = 0,
    FORMAT_BRIEF,
    FORMAT_PROCESS,
    FORMAT_TAG,
    FORMAT_THREAD,
    FORMAT_RAW,
    FORMAT_TIME,
    FORMAT_THREADTIME,
    FORMAT_LONG,
} AndroidLogPrintFormat;
```
枚举 `AndroidLogPrintFormat` 用来描述日志记录的输出格式，它一共有九个值，分别表示九种不同的输出格式。在分析日志记录的输出过程时，我们再分析它们的含义。

#### enum AndroidLogEntry_t
`system/core/include/cutils/logprint.h`
```cpp
typedef struct AndroidLogEntry_t {
    time_t tv_sec;
    long tv_nsec;
    android_LogPriority priority;
    pid_t pid;
    pthread_t tid;
    const char * tag;
    size_t messageLen;
    const char * message;
} AndroidLogEntry;
```
与结构体 `logger_entry` 一样，结构体 `AndroidLogEntry_t` 也是用来描述一条日志记录的，不过，它描述的日志记录是经过解析了的，即已经将它的优先级、标签和内容都解析出来了，分别保存在成员变量 `priority` 、 `tag` 和 `message` 中。

#### enum FilterInfo_t
`system/core/liblog/logprint.c`
```cpp
typedef struct FilterInfo_t {
    char *mTag;
    android_LogPriority mPri;
    struct FilterInfo_t *p_next;
} FilterInfo;
```
结构体 `FilterInfo_t` 用来描述一个日志记录输出过滤器。成员变量 `mTag` 和 `mPri` 分别表示要过滤的日志记录的标签和优先级。当一条日志记录的标签等于mTag时，如果它的优先级大于等于 `mPri` ，那么它就会被输出，否则就会被忽略。成员变量 `p_next` 用来连接下一个日志记录输出过滤器，这样就可以将所有的日志记录输出过滤器连接在一起形成一个队列。

#### enum AndroidLogFormat_t
`system/core/liblog/logprint.c`
```cpp
struct AndroidLogFormat_t {
    android_LogPriority global_pri;
    FilterInfo *filters;
    AndroidLogPrintFormat format;
};
```
结构体 `AndroidLogFormat_t` 用来保存日志记录的输出格式以及输出过滤器。其中，成员变量 `global_pri` 是一个全局设置的默认日志记录输出过滤优先级，成员变量 `filters` 是一个日志记录输出过滤器列表，而成员变量 `format` 用来保存具体的日志记录输出格式。当日志记录输出过滤器列表 `filters` 中的某一个过滤器的过滤优先级被设置为默认优先级 `ANDROID_LOG_DEFAULT` 时，系统就会将它的过滤优先级修改为 `global_pri` 。

#### enum EventTag
`system/core/loglib/event_tag_map.c`
```cpp
typedef struct EventTag {
    unsigned int    tagIndex;
    const char*     tagStr;
} EventTag;
```
结构体 `EventTag` 用来描述类型为 `events` 的日志记录的标签号，每一个标签号（ `tagIndex` ）都对应有一个文本描述字符串（ `tagStr` ）。这些对应关系是通过解析目标设备上的 `/system/etc/event-log-tags` 文件得到的。

#### enum EventTagMap
`system/core/loglib/event_tag_map.c`
```cpp
struct EventTagMap {
    /* memory-mapped source file; we get strings from here */
    void*           mapAddr;
    size_t          mapLen;

    /* array of event tags, sorted numerically by tag index */
    EventTag*       tagArray;
    int             numTags;
};
```
结构体 `EventTagMap` 用来描述类型为 `events` 的日志记录的内容格式，它同样是通过解析目标设备上的 `/system/etc/event-log-tags` 文件得到的。 `Logcat` 工具在打开目标设备上的 `/system/etc/event-log-tags` 文件时，会把它的内容映射到内存中，其中，成员变量 `mapAddr` 就指向这块内存的起始地址；成员变量 `mapLen` 表示该内存的大小；成员变量 `tagArray` 是一个 `EventTag` 类型的数组，数组的大小由成员变量 `numTags` 来描述。

### 4.6.2　初始化过程
`Logcat` 工具的初始化过程是从文件 `logcat.cpp `中的函数 `main` 开始的，它会打开日志设备和解析命令行参数。这个函数的实现代码比较长，我们分段来阅读。

`system/core/logcat/logcat.cpp`
```cpp
001 static AndroidLogFormat * g_logformat;
002 static bool g_nonblock = false;
003 static int g_tail_lines = 0;
004 
005 static const char * g_outputFileName = NULL;
006 static int g_logRotateSizeKBytes = 0;                   // 0 means "no log rotation"
007 static int g_maxRotatedLogs = DEFAULT_MAX_ROTATED_LOGS; // 0 means "unbounded"
008 static int g_outFD = -1;
009 static off_t g_outByteCount = 0;
010 static int g_printBinary = 0;
011 static int g_devCount = 0;
012 
013 static EventTagMap* g_eventTagMap = NULL;
014 
015 int main(int argc, char **argv)
016 {
017     int err;
018     int hasSetLogFormat = 0;
019     int clearLog = 0;
020     int getLogSize = 0;
021     int mode = O_RDONLY;
022     const char *forceFilters = NULL;
023     log_device_t* devices = NULL;
024     log_device_t* dev;
025     bool needBinary = false;
026 
027     g_logformat = android_log_format_new();
        ......
```
第 `27` 行调用函数 `android_log_format_new` 来创建一个全局的日志记录输出格式和输出过滤器对象 `g_logformat` 。

`system/core/liblog/logprint.c`
```cpp
AndroidLogFormat *android_log_format_new()
{
    AndroidLogFormat *p_ret;

    p_ret = calloc(1, sizeof(AndroidLogFormat));

    p_ret->global_pri = ANDROID_LOG_VERBOSE;
    p_ret->format = FORMAT_BRIEF;

    return p_ret;
}
```
从函数 `android_log_format_new` 的实现就可以看出，全局变量 `g_logformat` 指定的日志记录输出格式为 `FORMAT_BRIEF` ，而指定的全局默认日志记录过滤优先级为 `ANDROID_LOG_VERBOSE` 。

回到函数 `main` 中，我们继续往下分析。

`system/core/logcat/logcat.cpp`
```cpp
028 
029     if (argc == 2 && 0 == strcmp(argv[1], "--test")) {
030         logprint_run_tests();
031         exit(0);
032     }
033 
034     if (argc == 2 && 0 == strcmp(argv[1], "--help")) {
035         android::show_help(argv[0]);
036         exit(0);
037     }
038 
039     for (;;) {
040         int ret;
041 
042         ret = getopt(argc, argv, "cdt:gsQf:r::n:v:b:B");
043 
044         if (ret < 0) {
045             break;
046         }
047 
048         switch(ret) {
049             case 's': 
050                 // default to all silent
051                 android_log_addFilterRule(g_logformat, "*:s");
052             break;
053 
054             case 'c':
055                 clearLog = 1;
056                 mode = O_WRONLY;
057             break;
058 
059             case 'd':
060                 g_nonblock = true;
061             break;
062 
063             case 't':
064                 g_nonblock = true;
065                 g_tail_lines = atoi(optarg);
066             break;
067 
068             case 'g':
069                 getLogSize = 1;
070             break;
071 
072             case 'b': {
073                 char* buf = (char*) malloc(strlen(LOG_FILE_DIR) + strlen(optarg) + 1);
074                 strcpy(buf, LOG_FILE_DIR);
075                 strcat(buf, optarg);
076 
077                 bool binary = strcmp(optarg, "events") == 0;
078                 if (binary) {
079                     needBinary = true;
080                 }
081 
082                 if (devices) {
083                     dev = devices;
084                     while (dev->next) {
085                         dev = dev->next;
086                     }
087                     dev->next = new log_device_t(buf, binary, optarg[0]);
088                 } else {
089                     devices = new log_device_t(buf, binary, optarg[0]);
090                 }
091                 android::g_devCount++;
092             }
093             break;
094 
095             case 'B':
096                 android::g_printBinary = 1;
097             break;
098 
099             case 'f':
100                 // redirect output to a file
101 
102                 android::g_outputFileName = optarg;
103 
104             break;
105 
106             case 'r':
107                 if (optarg == NULL) {                
108                     android::g_logRotateSizeKBytes 
109                                 = DEFAULT_LOG_ROTATE_SIZE_KBYTES;
110                 } else {
111                     long logRotateSize;
112                     char *lastDigit;
113 
114                     if (!isdigit(optarg[0])) {
115                         fprintf(stderr,"Invalid parameter to -r\n");
116                         android::show_help(argv[0]);
117                         exit(-1);
118                     }
119                     android::g_logRotateSizeKBytes = atoi(optarg);
120                 }
121             break;
122 
123             case 'n':
124                 if (!isdigit(optarg[0])) {
125                     fprintf(stderr,"Invalid parameter to -r\n");
126                     android::show_help(argv[0]);
127                     exit(-1);
128                 }
129 
130                 android::g_maxRotatedLogs = atoi(optarg);
131             break;
132 
133             case 'v':
134                 err = setLogFormat (optarg);
135                 if (err < 0) {
136                     fprintf(stderr,"Invalid parameter to -v\n");
137                     android::show_help(argv[0]);
138                     exit(-1);
139                 }
140 
141                 hasSetLogFormat = 1;
142             break;
143 
144             case 'Q':
145                 /* this is a *hidden* option used to start a version of logcat                 */
146                 /* in an emulated device only. it basically looks for androidboot.logcat=      */
147                 /* on the kernel command line. If something is found, it extracts a log filter */
148                 /* and uses it to run the program. If nothing is found, the program should     */
149                 /* quit immediately                                                            */
150 #define  KERNEL_OPTION  "androidboot.logcat="
151 #define  CONSOLE_OPTION "androidboot.console="
152                 {
153                     int          fd;
154                     char*        logcat;
155                     char*        console;
156                     int          force_exit = 1;
157                     static char  cmdline[1024];
158 
159                     fd = open("/proc/cmdline", O_RDONLY);
160                     if (fd >= 0) {
161                         int  n = read(fd, cmdline, sizeof(cmdline)-1 );
162                         if (n < 0) n = 0;
163                         cmdline[n] = 0;
164                         close(fd);
165                     } else {
166                         cmdline[0] = 0;
167                     }
168 
169                     logcat  = strstr( cmdline, KERNEL_OPTION );
170                     console = strstr( cmdline, CONSOLE_OPTION );
171                     if (logcat != NULL) {
172                         char*  p = logcat + sizeof(KERNEL_OPTION)-1;;
173                         char*  q = strpbrk( p, " \t\n\r" );;
174 
175                         if (q != NULL)
176                             *q = 0;
177 
178                         forceFilters = p;
179                         force_exit   = 0;
180                     }
181                     /* if nothing found or invalid filters, exit quietly */
182                     if (force_exit)
183                         exit(0);
184 
185                     /* redirect our output to the emulator console */
186                     if (console) {
187                         char*  p = console + sizeof(CONSOLE_OPTION)-1;
188                         char*  q = strpbrk( p, " \t\n\r" );
189                         char   devname[64];
190                         int    len;
191 
192                         if (q != NULL) {
193                             len = q - p;
194                         } else
195                             len = strlen(p);
196 
197                         len = snprintf( devname, sizeof(devname), "/dev/%.*s", len, p );
198                         fprintf(stderr, "logcat using %s (%d)\n", devname, len);
199                         if (len < (int)sizeof(devname)) {
200                             fd = open( devname, O_WRONLY );
201                             if (fd >= 0) {
202                                 dup2(fd, 1);
203                                 dup2(fd, 2);
204                                 close(fd);
205                             }
206                         }
207                     }
208                 }
209                 break;
210 
211             default:
212                 fprintf(stderr,"Unrecognized Option\n");
213                 android::show_help(argv[0]);
214                 exit(-1);
215             break;
216         }
217     }
        ......
```
函数第 26 行到第 102 行的 `for` 循环依次对命令行参数进行解析。命令行参数的字符串解析是通过调用函数 `getopt` 来实现的，它的返回值 `ret` 表示命令行中的一个选项，而选项对应的值保存在变量 `optarg` 中。接下来，我们就分别对命令行中的选项 `d` 、 `t` 、 `b` 、 `B` 、 `f` 、 `r` 、 `n` 和 `v` 进行介绍。

如果使用选项 `d` 来启动 `Logcat` 工具，那么函数第 35 行就会把全局变量 `g_nonblock` 的值设置为 `true` ，表示当 `Logger` 日志驱动程序中没有日志记录可读时， `Logcat` 工具就直接退出。

如果使用选项 `t` 来启动 `Logcat` 工具，那么函数第 39 行就会将选项后面的数字保存在全局变量 `g_tail_lines` 中，同时第 38 行会将全局变量 `g_nonblock` 的值设置为 `true` 。其中，全局变量 `g_tail_lines` 表示 `Logcat` 工具每次在输出日志记录时，只输出最新的日志记录条数。

如果使用选项 `b` 来启动 `Logcat` 工具，那么函数第 `52` 行到第 `60` 行代码就会将选项后面的字符串取出来，并且为它创建一个 `log_device_t` 结构体，表示 `Logcat` 工具要打开的日志设备。选项后面的字符串的取值为 `main` 、 `radio` 或者 `events` ，表示要打开的日志设备分别为`/dev/log/main`、 `/dev/log/radio` 或者 `/dev/log/events` 。当选项后面的字符串为 `events` 时，函数第49行会将变量needBinary的值设置为true，表示 `Logcat` 工具要解析目标设备上的 `/system/etc/event-log-tags` 文件的内容，以便可以将日志设备 `/dev/log/events` 的内容从二进制格式转换为文本格式。每次创建一个 `log_device_t` 结构体时，全局变量g_devCount的值就会加1，表示 `Logcat` 工具所打开的日志设备个数。

**注意**
> 如果在启动 `Logcat` 工具时，没有使用选项b，那么 `Logcat` 工具默认打开的日志设备就为`/dev/log/main`。

如果使用选项 `B` 来启动 `Logcat` 工具，那么函数第 65 行就会将全局变量 `g_printBinary` 的值设置为 1 ，表示要以二进制格式来输出日志记录。这时候就不需要对日志记录的内容进行解析了。

如果使用选项 `f` 来启动 `Logcat` 工具，那么函数第 70 行就会将选项后面的字符串取出来，并且保存在全局变量 `g_outputFileName` 中，用作日志记录的输出文件名称。当输入到文件 `g_outputFileName` 的日志记录的大小（单位是字节）达到设定的量时， `Logcat` 工具就会将接下来的日志记录输出到另外一个文件中，直到这个文件的日志记录的大小也达到设定的量为止。用作日志记录输出的文件的命名方式是遵循一定的规律的。例如，假设选项f后面的字符串为 `logfile` ，那么第一个日志记录输出文件的名称就为 `logfile` ，接下来的日志记录输出文件的名称依次为 `logfile.1` 、 `logfile.2` 、 `logfile.3` 等。日志记录输出文件的大小由选项 `r` 来指定，而日志记录输出文件的个数由选项 `n` 来指定。当日志记录输出文件的个数达到设定的值时，并且每一个日志记录输出文件的大小也达到设定的值时， `Logcat` 工具就会循环使用已有的日志记录输出文件，即将原来的日志记录输出文件的内容擦掉，然后将新的日志记录写入到这些文件中。

如果使用选项 `r` 来启动 `Logcat` 工具，那么函数第 84 行就会将选项后面的数字保存在全局变量 `g_logRotateSizeKBytes` 中，用来表示每一个日志记录输出文件的最大容量。如果该选项后面没有指定数字，那么全局变量 `g_logRotateSizeKBytes` 的值就默认设置为 `DEFAULT_LOG_ROTATE_SIZE_KBYTES` 。

`system/core/logcat/logcat.cpp`
```cpp
#define DEFAULT_LOG_ROTATE_SIZE_KBYTES 16
```
全局变量 `g_logRotateSizeKBytes` 的值被初始化为 0 ，表示所有的日志记录输出文件的容量没有限制，这会导致所有的日志记录都输出到文件 `g_outputFileName` 中。

如果使用选项n来启动 `Logcat` 工具，那么函数第 92 行就会将选项后面的数字保存在全局变量 `g_maxRotatedLogs` 中，表示日志记录输出文件的最大个数。全局变量 `g_maxRotateLogs` 的值被初始化为 `DEFAULT_MAX_ROTATED_LOGS` 。

`system/core/logcat/logcat.cpp`
```cpp
#define DEFAULT_MAX_ROTATED_LOGS 4
```
如果使用选项 `v` 来启动 `Logcat` 工具，那么函数第 95 行就会调用函数 `setLogFormat` 将选项后面的字符串转换为相应的 `AndroidLogPrintFormat` 枚举值。该选项后面的字符串取值为 `brief` 、 `process` 、 `tag` 、 `thread` 、 `raw` 、 `time` 、 `threadtime` 或者 `long` ，分别对应于枚举 `AndroidLogPrintFormat` 中的每一个值。

函数 `setLogFormat` 的实现如下所示。

`system/core/logcat/logcat.cpp`
```cpp
01 static int setLogFormat(const char * formatString)
02 {
03     static AndroidLogPrintFormat format;
04 
05     format = android_log_formatFromString(formatString);
06 
07     if (format == FORMAT_OFF) {
08         // FORMAT_OFF means invalid string
09         return -1;
10     }
11 
12     android_log_setPrintFormat(g_logformat, format);
13 
14     return 0;
15 }
```
第 `5` 行调用函数 `android_log_formatFromString` 将字符串 `formatString` 转换为一个 `AndroidLogPrintFormat` 枚举值。

`system/core/liblog/logprint.c`
```cpp
AndroidLogPrintFormat android_log_formatFromString(const char * formatString)
{
    static AndroidLogPrintFormat format;

    if (strcmp(formatString, "brief") == 0) format = FORMAT_BRIEF;
    else if (strcmp(formatString, "process") == 0) format = FORMAT_PROCESS;
    else if (strcmp(formatString, "tag") == 0) format = FORMAT_TAG;
    else if (strcmp(formatString, "thread") == 0) format = FORMAT_THREAD;
    else if (strcmp(formatString, "raw") == 0) format = FORMAT_RAW;
    else if (strcmp(formatString, "time") == 0) format = FORMAT_TIME;
    else if (strcmp(formatString, "threadtime") == 0) format = FORMAT_THREADTIME;
    else if (strcmp(formatString, "long") == 0) format = FORMAT_LONG;
    else format = FORMAT_OFF;

    return format;
}
```
如果参数 `formatString` 是一个非法字符串，那么函数 `android_log_formatFromString` 就会将它转换为一个 `FORMAT_OFF` 值；否则，就通过第 5 行到第 12 行代码来得到正确的 `AndroidLogPrintFormat` 枚举值。

回到函数 `setLogFormat` 中，将前面得到的日志记录输出格式保存在变量 `format` 中，接着第 12 行继续调用函数 `android_log_setPrintFormat` 将变量 `format` 的值设置到全局变量 `g_logformat` 的成员变量 `format` 中，用来描述 `Logcat` 工具的日志记录输出格式。

`system/core/liblog/logprint.c`
```cpp
void android_log_setPrintFormat(AndroidLogFormat *p_format,
        AndroidLogPrintFormat format)
{
    p_format->format=format;
}
```
回到 `main` 函数中，如果指定了选项 `v` ，并且成功地对它进行了解析，那么函数第 `98` 行就会将变量 `hasSetLogFormat` 的值设置为 `1` ，表示设置了 `Logcat` 工具的日志记录输出格式。

函数 `main` 解析完成命令行参数后，继续往下执行。

`system/core/logcat/logcat.cpp`
```cpp
219     if (!devices) {
220         devices = new log_device_t(strdup("/dev/"LOGGER_LOG_MAIN), false, 'm');
221         android::g_devCount = 1;
222         int accessmode =
223                   (mode & O_RDONLY) ? R_OK : 0
224                 | (mode & O_WRONLY) ? W_OK : 0;
225         // only add this if it's available
226         if (0 == access("/dev/"LOGGER_LOG_SYSTEM, accessmode)) {
227             devices->next = new log_device_t(strdup("/dev/"LOGGER_LOG_SYSTEM), false, 's');
228             android::g_devCount++;
229         }
230     }
```
如果启动 `Logcat` 工具时，没有指定选项 `b` ，那么变量 `devices` 的值就会等于 `NULL` 。这时候 `Logcat` 工具就会默认打开日志设备`/dev/log/main`来读取它的日志记录。如果日志设备 `/dev/log/system` 也存在，那么 `Logcat` 工具也会一起打开它来读取日志记录。

打开要读取日志记录的日志设备之后，函数 `main` 继续往下执行。

`system/core/logcat/logcat.cpp`
```cpp
231 
232     if (android::g_logRotateSizeKBytes != 0 
233         && android::g_outputFileName == NULL
234     ) {
235         fprintf(stderr,"-r requires -f as well\n");
236         android::show_help(argv[0]);
237         exit(-1);
238     }
239 
240     android::setupOutput();
```
第 115 行调用函数 `setupOutput` 来设置日志记录是输出到文件中还是打印到标准输出中，它的实现如下所示。

`system/core/logcat/logcat.cpp`
```cpp
static void setupOutput()
{

    if (g_outputFileName == NULL) {
        g_outFD = STDOUT_FILENO;

    } else {
        struct stat statbuf;

        g_outFD = openLogFile (g_outputFileName);

        if (g_outFD < 0) {
            perror ("couldn't open output file");
            exit(-1);
        }

        fstat(g_outFD, &statbuf);

        g_outByteCount = statbuf.st_size;
    }
}
```
第 4 行判断全局变量 `g_outputFileName` 的值是否等于 `NULL` 。如果是，则说明要把日志记录打印到标准输出中，因此就将全局变量 `g_outFD` 指向标准输出文件描述符 `STDOUT_FILENO` ；否则，就要将日志记录输出到文件 `g_outputFileName` 中。如果是将日志记录输出到文件中，那么函数第 `10` 行调用 `openLogFile` 函数以 `APPEND` 方式打开日志记录输出文件 `g_outputFileName` 。

`system/core/logcat/logcat.cpp`
```cpp
static int openLogFile (const char *pathname)
{
    return open(g_outputFileName, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR);
}
```
回到函数 `setupOutput` 中，第 17 行获得当前日志记录输出文件 `g_outputFileName` 的大小，并且将它保存在全局变量 `g_outByteCount` 中。接下来 `Logcat` 工具往文件 `g_outputFileName` 输出日志记录时，就会相应地增加全局变量 `g_outByteCount` 的值。当全局变量 `g_outByteCount` 的值达到 `g_logRotateSizeKBytes` 时， `Logcat` 工具就会将后面的日志记录输出到另外一个文件中。

回到函数 `main` 中，继续往下执行。

`system/core/logcat/logcat.cpp`
```cpp
242     if (hasSetLogFormat == 0) {
243         const char* logFormat = getenv("ANDROID_PRINTF_LOG");
244 
245         if (logFormat != NULL) {
246             err = setLogFormat(logFormat);
247 
248             if (err < 0) {
249                 fprintf(stderr, "invalid format in ANDROID_PRINTF_LOG '%s'\n", 
250                                     logFormat);
251             }
252         }
253     }
```
如果启动 `Logcat` 工具时，没有指定选项 `v` ，那么变量 `hasSetLogFormat` 的值就会等于 `0` ，表示没有指定日志记录的输出格式。这时候 `Logcat` 工具就会检查环境变量 `ANDROID_PRINTF_LOG` 的值。如果环境变量 `ANDROID_PRINTF_LOG` 存在，那么就会调用函数 `setLogFormat` 将它的值作为 `Logcat` 工具的日志记录输出格式。

设置好日志记录的输出格式之后，函数 `main` 继续往下执行。

`system/core/logcat/logcat.cpp`
```cpp
255     if (forceFilters) {
256         err = android_log_addFilterString(g_logformat, forceFilters);
257         if (err < 0) {
258             fprintf (stderr, "Invalid filter expression in -logcat option\n");
259             exit(0);
260         }
261     } else if (argc == optind) {
262         // Add from environment variable
263         char *env_tags_orig = getenv("ANDROID_LOG_TAGS");
264 
265         if (env_tags_orig != NULL) {
266             err = android_log_addFilterString(g_logformat, env_tags_orig);
267 
268             if (err < 0) { 
269                 fprintf(stderr, "Invalid filter expression in" 
270                                     " ANDROID_LOG_TAGS\n");
271                 android::show_help(argv[0]);
272                 exit(-1);
273             }
274         }
275     } else {
276         // Add from commandline
277         for (int i = optind ; i < argc ; i++) {
278             err = android_log_addFilterString(g_logformat, argv[i]);
279 
280             if (err < 0) { 
281                 fprintf (stderr, "Invalid filter expression '%s'\n", argv[i]);
282                 android::show_help(argv[0]);
283                 exit(-1);
284             }
285         }
286     }
```
在启动 `Logcat` 工具时，我们可以指定一个不公开的选项 `Q` ，这时候 `Logcat` 工具就会去读取目标设备上的 `/proc/cmdline` 文件，检查里面有没有设置日志记录输出过滤器。如果设置了，那么变量 `forceFilters` 就指向这个日志记录输出过滤器，因此，函数第 125 行就会调用函数 `android_log_addFilterString` 将它增加到 `Logcat` 工具的日志记录输出过滤器列表中。
如果启动 `Logcat` 工具时，没有指定选项 `Q` ，那么 `Logcat` 工具就会继续检查命令行是否还带有其他额外的参数。如果没有，即第 127 行的 `if` 语句为 `true` ，那么 `Logcat` 工具就会将环境变量 `ANDROID_LOG_TAGS` 的值作为日志记录输出的一个过滤器来使用。

如果启动 `Logcat` 工具时，没有指定选项 `Q` ，但是命令行带有额外的参数，那么函数第 137 行到第 140 行的 `for` 循环就会检查这些额外的参数是否是一个日志记录输出过滤表达式。例如，当使用下面的命令来启动 `Logcat` 工具时 : 

```bash
adb logcat LOGTAG:I
```
最后一个参数 `LOGTAG:I` 就称为日志记录输出过滤表达式。日志记录输出过滤表达式的格式为 `<tag>[:priority]` ，其中， `tag` 为任意字符串，表示一个日志记录标签； `priority` 是一个字符，表示一个日志记录优先级。合法的 `priority` 字符为数字 `0` 到 `9` ，或者字母 `v` 、 `d` 、 `i` 、 `w` 、 `f` 、 `s` 和 `*` ，它们的具体含义在后面会进一步解释。这时候函数第 138 行就会调用函数 `android_log_addFilterString` 来解析这些日志记录输出过滤表达式，并且将它增加到 `Logcat` 工具的日志记录输出过滤器列表中。

函数 `android_log_addFilterString` 的实现如下所示。

`system/core/liblog/logprint.c`
```cpp
/**
 * filterString: a comma/whitespace-separated set of filter expressions
 *
 * eg "AT:d *:i"
 *
 * returns 0 on success and -1 on invalid expression
 *
 * Assumes single threaded execution
 *
 */

int android_log_addFilterString(AndroidLogFormat *p_format,
        const char *filterString)
{
    char *filterStringCopy = strdup (filterString);
    char *p_cur = filterStringCopy;
    char *p_ret;
    int err;

    // Yes, I'm using strsep
    while (NULL != (p_ret = strsep(&p_cur, " \t,"))) {
        // ignore whitespace-only entries
        if(p_ret[0] != '\0') {
            err = android_log_addFilterRule(p_format, p_ret);

            if (err < 0) {
                goto error;
            }
        }
    }

    free (filterStringCopy);
    return 0;
error:
    free (filterStringCopy);
    return -1;
}
```
第二个参数 `filterString` 可以同时包括若干个日志记录输出过滤表达式，它们以空格、制表符或者逗号分割。每一个日志记录输出过滤表达式都是使用函数 `android_log_addFilterRule` 来解析的，它的实现如下所示。

`system/core/liblog/logprint.c`
```cpp
/**
 * filterExpression: a single filter expression
 * eg "AT:d"
 *
 * returns 0 on success and -1 on invalid expression
 *
 * Assumes single threaded execution
 */

int android_log_addFilterRule(AndroidLogFormat *p_format,
        const char *filterExpression)
{
    size_t i=0;
    size_t tagNameLength;
    android_LogPriority pri = ANDROID_LOG_DEFAULT;

    tagNameLength = strcspn(filterExpression, ":");

    if (tagNameLength == 0) {
        goto error;
    }

    if(filterExpression[tagNameLength] == ':') {
        pri = filterCharToPri(filterExpression[tagNameLength+1]);

        if (pri == ANDROID_LOG_UNKNOWN) {
            goto error;
        }
    }

    if(0 == strncmp("*", filterExpression, tagNameLength)) {
        // This filter expression refers to the global filter
        // The default level for this is DEBUG if the priority
        // is unspecified
        if (pri == ANDROID_LOG_DEFAULT) {
            pri = ANDROID_LOG_DEBUG;
        }

        p_format->global_pri = pri;
    } else {
        // for filter expressions that don't refer to the global
        // filter, the default is verbose if the priority is unspecified
        if (pri == ANDROID_LOG_DEFAULT) {
            pri = ANDROID_LOG_VERBOSE;
        }

        char *tagName;

// Presently HAVE_STRNDUP is never defined, so the second case is always taken
// Darwin doesn't have strnup, everything else does
#ifdef HAVE_STRNDUP
        tagName = strndup(filterExpression, tagNameLength);
#else
        //a few extra bytes copied...
        tagName = strdup(filterExpression);
        tagName[tagNameLength] = '\0';
#endif /*HAVE_STRNDUP*/

        FilterInfo *p_fi = filterinfo_new(tagName, pri);
        free(tagName);

        p_fi->p_next = p_format->filters;
        p_format->filters = p_fi;
    }

    return 0;
error:
    return -1;
}
```
第 17 行取得日志记录输出过滤表达式中冒号的位置，接着第 24 行就调用函数 `filterCharToPri` 将冒号后面的字符转换为 `android_LogPriority` 枚举值。

`system/core/liblog/logprint.c`
```cpp
/*
 * Note: also accepts 0-9 priorities
 * returns ANDROID_LOG_UNKNOWN if the character is unrecognized
 */
static android_LogPriority filterCharToPri (char c)
{
    android_LogPriority pri;

    c = tolower(c);

    if (c >= '0' && c <= '9') {
        if (c >= ('0'+ANDROID_LOG_SILENT)) {
            pri = ANDROID_LOG_VERBOSE;
        } else {
            pri = (android_LogPriority)(c - '0');
        }
    } else if (c == 'v') {
        pri = ANDROID_LOG_VERBOSE;
    } else if (c == 'd') {
        pri = ANDROID_LOG_DEBUG;
    } else if (c == 'i') {
        pri = ANDROID_LOG_INFO;
    } else if (c == 'w') {
        pri = ANDROID_LOG_WARN;
    } else if (c == 'e') {
        pri = ANDROID_LOG_ERROR;
    } else if (c == 'f') {
        pri = ANDROID_LOG_FATAL;
    } else if (c == 's') {
        pri = ANDROID_LOG_SILENT;
    } else if (c == '*') {
        pri = ANDROID_LOG_DEFAULT;
    } else {
        pri = ANDROID_LOG_UNKNOWN;
    }

    return pri;
}
```
从函数 `filterCharToPri` 的实现就可以看出，字符 `v` 、 `d` 、 `i` 、 `w` 、 `e` 、 `f` 、 `s` 和 `*` 对应的日志记录优先级分别为 `ANDROID_LOG_VERBOSE` 、 `ANDROID_LOG_DEBUG` 、 `ANDROID_LOG_INFO` 、 `ANDROID_LOG_WARN` 、 `ANDROID_LOG_ERROR` 、 `ANDROID_LOG_FATAL` 、 `ANDROID_LOG_SILENT` 和 `ANDROID_LOG_DEFAULT` 。此外，字符 `0` 到 `7` 对应的日志记录优先级分别为 `ANDROID_LOG_UNKNOWN` 、 `ANDROID_LOG_DEFAULT` 、 `ANDROID_LOG_VERBOSE` 、 `ANDROID_LOG_DEBUG` 、 `ANDROID_LOG_INFO` 、 `ANDROID_LOG_WARN` 、 `ANDROID_LOG_ERROR` 和 `ANDROID_LOG_FATAL` ，而字符 `8` 和 `9` 对应的日志记录优先级均为 `ANDROID_LOG_VERBOSE` 。

回到函数 `android_log_addFilterRule` 中，如果日志记录输出过滤表达式中的日志记录标签值为 `*` ，即第 31 行的 `if` 语句为 `true` ，就表示要将它的日志记录优先级设置为全局的日志记录过滤优先级；否则，就为该日志记录输出过滤表达式创建一个日志记录输出过滤器，并且增加到 `Logcat` 工具的日志记录输出过滤器列表中，如第 59 行到第 63 行代码所示。

设置好日志记录输出过滤器列表之后，回到函数 `main` 中，继续往下执行。

`system/core/logcat/logcat.cpp`
```cpp
288     dev = devices;
289     while (dev) {
290         dev->fd = open(dev->device, mode);
291         if (dev->fd < 0) {
292             fprintf(stderr, "Unable to open log device '%s': %s\n",
293                 dev->device, strerror(errno));
294             exit(EXIT_FAILURE);
295         }
296 
297         if (clearLog) {
298             int ret;
299             ret = android::clearLog(dev->fd);
300             if (ret) {
301                 perror("ioctl");
302                 exit(EXIT_FAILURE);
303             }
304         }
305 
306         if (getLogSize) {
307             int size, readable;
308 
309             size = android::getLogSize(dev->fd);
310             if (size < 0) {
311                 perror("ioctl");
312                 exit(EXIT_FAILURE);
313             }
314 
315             readable = android::getLogReadableSize(dev->fd);
316             if (readable < 0) {
317                 perror("ioctl");
318                 exit(EXIT_FAILURE);
319             }
320 
321             printf("%s: ring buffer is %dKb (%dKb consumed), "
322                    "max entry is %db, max payload is %db\n", dev->device,
323                    size / 1024, readable / 1024,
324                    (int) LOGGER_ENTRY_MAX_LEN, (int) LOGGER_ENTRY_MAX_PAYLOAD);
325         }
326 
327         dev = dev->next;
328     }
```
函数第 143 行到 148 行的 `while` 循环依次调用函数 `open` 来打开保存在 `devices` 列表中的各个日志设备，并且将得到的文件描述符保存在对应的日志设备的成员变量 `fd` 中。

日志设备打开之后，函数 `main` 继续往下执行。

`system/core/logcat/logcat.cpp`
```cpp
341     if (needBinary)
342         android::g_eventTagMap = android_openEventTagMap(EVENT_TAG_MAP_FILE);
343 
344     android::readLogLines(devices);
345 
346     return 0;
347 }
```
函数第 149 行判断打开的日志设备的日志记录格式是否包含二进制格式，即是否打开了日志设备 `/dev/log/events` 。如果是，即第 149 行的 `if` 语句为 `true` ，那么第 150 行就会调用函数 `android_openEventTagMap` 来解析目标设备上的 `/system/etc/event-log-tags` 文件，因为 `Logcat` 工具需要根据它的内容来解析类型为 `events` 的日志记录。函数 `android_openEventTagMap` 的返回值是一个 `EventTagMap` 结构体，保存在全局变量 `g_eventTagMap` 中。

`EVENT_TAG_MAP_FILE` 是一个宏定义，它的值为 `/system/etc/event-log-tags` ，如下所示。

`system/core/include/cutils/event_tag_map.h`
```cpp
#define EVENT_TAG_MAP_FILE  "/system/etc/event-log-tags"
```
函数 `android_openEventTagMap` 的实现如下所示。

`system/core/liblog/event_tag_map.c`
```cpp
/*
 * Open the map file and allocate a structure to manage it.
 *
 * We create a private mapping because we want to terminate the log tag
 * strings with '\0'.
 */
EventTagMap* android_openEventTagMap(const char* fileName)
{
    EventTagMap* newTagMap;
    off_t end;
    int fd = -1;

    newTagMap = calloc(1, sizeof(EventTagMap));
    if (newTagMap == NULL)
        return NULL;

    fd = open(fileName, O_RDONLY);
    if (fd < 0) {
        fprintf(stderr, "%s: unable to open map '%s': %s\n",
            OUT_TAG, fileName, strerror(errno));
        goto fail;
    }

    end = lseek(fd, 0L, SEEK_END);
    (void) lseek(fd, 0L, SEEK_SET);
    if (end < 0) {
        fprintf(stderr, "%s: unable to seek map '%s'\n", OUT_TAG, fileName);
        goto fail;
    }

    newTagMap->mapAddr = mmap(NULL, end, PROT_READ | PROT_WRITE, MAP_PRIVATE,
                                fd, 0);
    if (newTagMap->mapAddr == MAP_FAILED) {
        fprintf(stderr, "%s: mmap(%s) failed: %s\n",
            OUT_TAG, fileName, strerror(errno));
        goto fail;
    }
    newTagMap->mapLen = end;

    if (processFile(newTagMap) != 0)
        goto fail;

    return newTagMap;

fail:
    android_closeEventTagMap(newTagMap);
    if (fd >= 0)
        close(fd);
    return NULL;
}
```
第 `13` 行首先创建一个 `EventTagMap` 结构体对象，接着第 17 行打开文件 `/system/etc/event-log-tags` ，第 24 行得到该文件的大小，第 31 行将该文件的内容映射到内存中，最后第 41 行调用函数 `processFile` 来解析文件 `/system/etc/event-log-tags` 中的内容。

`system/core/liblog/event_tag_map.c`
```cpp
/*
 * Crunch through the file, parsing the contents and creating a tag index.
 */
static int processFile(EventTagMap* map)
{
    EventTag* tagArray = NULL;

    /* get a tag count */
    map->numTags = countMapLines(map);
    if (map->numTags < 0)
        return -1;

    //printf("+++ found %d tags\n", map->numTags);

    /* allocate storage for the tag index array */
    map->tagArray = calloc(1, sizeof(EventTag) * map->numTags);
    if (map->tagArray == NULL)
        return -1;

    /* parse the file, null-terminating tag strings */
    if (parseMapLines(map) != 0) {
        fprintf(stderr, "%s: file parse failed\n", OUT_TAG);
        return -1;
    }

    /* sort the tags and check for duplicates */
    if (sortTags(map) != 0)
        return -1;

    return 0;
}
```
第 9 行调用函数 `countMapLines` 来计算文件 `/system/etc/event-log-tags` 的行数，接着第 16 行根据这个行数来分配一个 `EventTag` 结构体数组，其中，每一行的内容都对应一个 `EventTag` 结构体。第 21 行调用函数 `parseMapLines` 来解析文件 `/system/etc/event-log-tags` 的内容。函数 `countMapLines` 主要是根据文件中的换行符 `\n` 来计算行数，而且会忽略文件中的空白行和注释行。函数 `parseMapLines` 对文件中的每一行内容进行解析，从而得到类型为 `events` 的日志记录标签描述表。下面我们就通过一个例子来说明函数 `parseMapLines` 的工作原理。

当目标设备上的文件 `/system/etc/event-log-tags` 包含以下一行内容时:
```bash
2722 battery_level (level|1|6),(voltage|1|1),(temperature|1|1)
```
函数 `parseMapLines` 就会将字符串 `2722` 转换为数字 `2722` ，并且将它保存在一个 `EventTag` 结构体的成员变量 `tagIndex` 中，然后再将字符 `battery_level` 在内存中的地址保存在同一个 `EventTag` 结构体的成员变量 `tagStr` 中，从而将日志记录标签号 `2722` 与描述字符串 `battery_level` 关联起来。

函数 `parseMapLines` 执行完成之后，我们就得到了类型为 `events` 的日志记录的日志标签描述表，它保存在一个 `EventTagMap` 结构体内部的数组 `tagArray` 中。为了使后面能够根据日志标签号快速找到对应的日志标签描述字符串，函数 `processFile` 的第 27 行调用函数 `sortTags` 对这个数组进行排序。

`system/core/liblog/event_tag_map.c`
```cpp
/*
 * Sort the EventTag array so we can do fast lookups by tag index.  After
 * the sort we do a quick check for duplicate tag indices.
 *
 * Returns 0 on success.
 */
static int sortTags(EventTagMap* map)
{
    int i;

    qsort(map->tagArray, map->numTags, sizeof(EventTag), compareEventTags);

    for (i = 1; i < map->numTags; i++) {
        if (map->tagArray[i].tagIndex == map->tagArray[i-1].tagIndex) {
            fprintf(stderr, "%s: duplicate tag entries (%d:%s and %d:%s)\n",
                OUT_TAG,
                map->tagArray[i].tagIndex, map->tagArray[i].tagStr,
                map->tagArray[i-1].tagIndex, map->tagArray[i-1].tagStr);
            return -1;
        }
    }

    return 0;
}
```

第 11 行调用快排函数 `qsort` 对该日志标签描述数组进行排序，指定的比较函数为 `compareEventTags` ，它的实现如下所示。

`system/core/liblog/event_tag_map.c`
```cpp
/*
 * Compare two EventTags.
 */
static int compareEventTags(const void* v1, const void* v2)
{
    const EventTag* tag1 = (const EventTag*) v1;
    const EventTag* tag2 = (const EventTag*) v2;

    return tag1->tagIndex - tag2->tagIndex;
}
```
从这里就可以看出，日志标签描述数组的元素是按照日志标签号从小到大排列的。

回到函数 `sortTags` 中，第 13 行到第 21 行的 `for` 循环检查前面获得的日志标签描述数组的合法性，即检查它里面是否有重复的日志标签号。如果有，就会返回错误码 `-1` ，表示目标设备上的文件 `/system/etc/event-log-tags` 的内容有问题。

解析完成目标设备上的文件 `/system/etc/event-log-tags` 之后，回到函数 `main` 中，继续往下执行。

`system/core/logcat/logcat.cpp`
```cpp
344     android::readLogLines(devices);
345 
346     return 0;
347 }
```
第 151 行调用函数 `readLogLines` 开始读取前面打开的日志设备的日志记录。接下来，我们就分析这些日志记录的读取过程。

### 4.6.3　日志记录的读取过程
从前面 `4.6.2` 小节的内容可以知道， `Logcat` 工具是从源代码文件 `logcat.cpp` 中的函数 `readLogLines` 开始读取日志记录的，我们分段来阅读这个函数的实现。

`system/core/logcat/logcat.cpp`
```cpp
static void readLogLines(log_device_t* devices)
{
    log_device_t* dev;
    int max = 0;
    int ret;
    int queued_lines = 0;
    bool sleep = true;

    int result;
    fd_set readset;

    for (dev=devices; dev; dev = dev->next) {
        if (dev->fd > max) {
            max = dev->fd;
        }
    }

    while (1) {
        do {
            timeval timeout = { 0, 5000 /* 5ms */ }; // If we oversleep it's ok, i.e. ignore EINTR.
            FD_ZERO(&readset);
            for (dev=devices; dev; dev = dev->next) {
                FD_SET(dev->fd, &readset);
            }
            result = select(max + 1, &readset, NULL, NULL, sleep ? NULL : &timeout);
        } while (result == -1 && errno == EINTR);
```
由于 `Logcat` 工具有可能同时打开了多个日志设备，因此，第 19 行到第 26 行的 `while` 循环就使用函数 `select` 来同时监控它们是否有内容可读，即是否有新的日志记录需要读取。调用函数 `select` 时，需要指定所监控的日志设备文件描述符的最大值，因此，第 12 行到第 16 行的 `for` 循环就用来查找这些打开的日志设备中的最大文件描述符，并保存在变量 `max` 中。在调用函数 `select` 之前，第22行到第 24 行的 `for` 循环把所有打开的日志设备的文件描述符都保存到一个 `fd_set` 对象 `readset` 中，接着第 25 行就调用函数 `select` 来监控前面所打开的日志设备是否有新的日志记录可读，其中，指定的等待时间为 `5` 毫秒，即如果在 `5` 毫秒之内，所有打开的日志设备都没有新的日志记录可读，那么函数 `select` 就超时返回，即它的返回值为0；否则，函数 `select` 就会将 `fd_set` 对象 `readset` 中的相应位设置为 `1` ，表示该位所对应的日志设备有新的日志记录可读，这时候函数 `select` 的返回值是大于0的。如果在调用函数 `select` 的过程中， `Logcat` 工具有信号需要处理，那么函数 `select` 的返回值就会等于 `-1` ，并且错误代码 `errno` 等于 `EINTR` ，表示 `Logcat` 工具需要重新调用函数 `select` 来检查打开的日志设备是否有新的日志记录可读。

当函数跳出第 19 行到 26 行的 `while` 循环之后，有可能是等待超时，也有可能是所监控的日志设备中有新的日志记录可读，因此，我们需要分两种情况来分析日志记录的读取过程。

首先分析日志设备中有新的日志记录可读的情况，如下所示。

`system/core/logcat/logcat.cpp`
```cpp
        if (result >= 0) {
            for (dev=devices; dev; dev = dev->next) {
                if (FD_ISSET(dev->fd, &readset)) {
                    queued_entry_t* entry = new queued_entry_t();
                    /* NOTE: driver guarantees we read exactly one full entry */
                    ret = read(dev->fd, entry->buf, LOGGER_ENTRY_MAX_LEN);
                    if (ret < 0) {
                        if (errno == EINTR) {
                            delete entry;
                            goto next;
                        }
                        if (errno == EAGAIN) {
                            delete entry;
                            break;
                        }
                        perror("logcat read");
                        exit(EXIT_FAILURE);
                    }
                    else if (!ret) {
                        fprintf(stderr, "read: Unexpected EOF!\n");
                        exit(EXIT_FAILURE);
                    }

                    entry->entry.msg[entry->entry.len] = '\0';

                    dev->enqueue(entry);
                    ++queued_lines;
                }
            }
```
第 28 行到第 55 行的 `for` 循环依次处理有新的日志记录可读的日志设备。如果一个日志设备有新的日志记录可读，那么第 29 行的 `if` 语句就会为 `true` ，接着第 30 行就会分配一个 `queued_entry_t` 结构体 `entry` ，并且第 32 行调用函数 `read` 把该日志设备中的一条新的日志记录读到结构体 `entry` 内部的缓冲区 `buf` 中。如果在读取日志记录的过程中出现错误，那么 `Logcat` 工具就会调用函数 `exit` 直接退出。但是如果错误码等于 `EINTR` 或者 `EAGAIN` ，就需要特殊处理。如果错误代码 `errno` 等于 `EINTR` ，就说明 `Logcat` 工具在读取日志记录的过程中被信号打断，因此， `Logcat` 工具会重新执行 `next` 标签处的代码，即重新执行第 18 行的 `while` 循环来监控所打开的日志设备中是否有新的日志记录可读。如果错误码等于 `EAGAIN` ，就说明该日志设备在打开时指定了 `O_NONBLOCK` 标志，即以非阻塞的模式来打开该日志设备，这时候 `Logcat` 工具就会跳出第 28 行的 `for` 循环，继续往下执行。

如果第 32 行成功地从相应的日志设备中读取到新的日志记录，那么第 52 行就会将它加入到相应的日志设备的日志记录队列中，并且第 53 行就会将队列中的日志记录计数 `queued_lines` 增加 `1` ，表示 `Logcat` 工具当前正在等待显示的日志记录条数。第 28 行的 `for` 循环执行完成之后，就从每个有新的日志记录的日志设备中读出一条日志记录。

**注意**
> 这些日志设备中的可读日志记录数可能不只一条，因此，接下来还需要执行第 18 行的 `while` 循环来继续读取这些日志设备中的其他日志记录。不过，在继续读取这些剩余的日志记录之前， `Logcat` 工具先处理前面已经从日志设备中读取出来的日志记录，如下所示。

`system/core/logcat/logcat.cpp`
```cpp

            if (result == 0) {
                // we did our short timeout trick and there's nothing new
                // print everything we have and wait for more data
                sleep = true;
                while (true) {
                    chooseFirst(devices, &dev);
                    if (dev == NULL) {
                        break;
                    }
                    if (g_tail_lines == 0 || queued_lines <= g_tail_lines) {
                        printNextEntry(dev);
                    } else {
                        skipNextEntry(dev);
                    }
                    --queued_lines;
                }

                // the caller requested to just dump the log and exit
                if (g_nonblock) {
                    exit(0);
                }
            } else {
                // print all that aren't the last in their list
                sleep = false;
                while (g_tail_lines == 0 || queued_lines > g_tail_lines) {
                    chooseFirst(devices, &dev);
                    if (dev == NULL || dev->queue->next == NULL) {
                        break;
                    }
                    if (g_tail_lines == 0) {
                        printNextEntry(dev);
                    } else {
                        skipNextEntry(dev);
                    }
                    --queued_lines;
                }
            }
        }
next:
        ;
    }
}
```
第 56 行到第 92 行的 `if` 语句块是用来处理日志记录输出的，主要通过 `chooseFirst` 、 `printNextEntry` 和 `skipNextEntry` 三个函数来实现。

由于 `Logcat` 工具是按照写入时间的先后顺序来输出日志记录的，因此，在输出已经读取的日志记录之前， `Logcat` 工具首先会调用函数 `chooseFirst` 找到包含有最早的未输出日志记录的日志设备，它的实现如下所示。

`system/core/logcat/logcat.cpp`
```cpp
static void chooseFirst(log_device_t* dev, log_device_t** firstdev) {
    for (*firstdev = NULL; dev != NULL; dev = dev->next) {
        if (dev->queue != NULL && (*firstdev == NULL || cmp(dev->queue, (*firstdev)->queue) < 0)) {
            *firstdev = dev;
        }
    }
}
```
因为每一个日志设备的日志队列都是按照写入时间的先后顺序来排列日志记录的，因此，函数 `chooseFirst` 只要比较日志队列中的第一个日志记录的写入时间，就可以找到包含有最早的未输出日志记录的日志设备。

真正用来输出日志记录的函数是 `printNextEntry` ，它的实现如下所示。

`system/core/logcat/logcat.cpp`
```cpp
static void printNextEntry(log_device_t* dev) {
    maybePrintStart(dev);
    if (g_printBinary) {
        printBinary(&dev->queue->entry);
    } else {
        processBuffer(dev, &dev->queue->entry);
    }
    skipNextEntry(dev);
}
```
第 2 行调用函数 `maybePrintStart` 来检查日志设备 `dev` 中的日志记录是否是第一次输出。如果是，就会首先输出一行提示性文字，如下所示。

`system/core/logcat/logcat.cpp`
```cpp
static void maybePrintStart(log_device_t* dev) {
    if (!dev->printed) {
        dev->printed = true;
        if (g_devCount > 1 && !g_printBinary) {
            char buf[1024];
            snprintf(buf, sizeof(buf), "--------- beginning of %s\n", dev->device);
            if (write(g_outFD, buf, strlen(buf)) < 0) {
                perror("output error");
                exit(-1);
            }
        }
    }
}
```
回到函数 `printNextEntry` 中，如果在启动 `Logcat` 工具时，指定了 `B` 选项，那么全局变量 `g_printBinary` 的值就会被设置为 `1` ，表示 `Logcat` 工具要以二进制格式来输出读取到的日志记录，因此，第 4 行就会调用函数 `printBinary` 来输出已经读取到的日志记录；否则，第 6 行就会调用函数 `processBuffer` 来输出已经读取到的日志记录。在接下来的 `4.6.4 `小节中分析日志记录的输出过程时，我们再详细分析这两个函数的实现。

日志队列中的日志记录输出之后，就要将它从队列中删除，这是通过调用函数 `skipNextEntry` 来实现的，如下所示。

`system/core/logcat/logcat.cpp`
```cpp
static void skipNextEntry(log_device_t* dev) {
    maybePrintStart(dev);
    queued_entry_t* entry = dev->queue;
    dev->queue = entry->next;
    delete entry;
}
```
回到函数 `readLogLines` 中，我们接着分析第 56 行到第 92 行的 `if` 语句块是如何处理那些已经从日志设备中读取出来的日志记录的。

如果变量 `result` 的值等于 0 ，即第 56 行的 `if` 语句为 `true` ，就说明前面在调用函数 `select` 监控日志设备中是否有新的日志记录可读时超时了。既然所有打开的日志设备都没有新的日志记录可读，第 60 行到第 71 行的 `while` 循环就是时候输出之前已经读取出来的日志记录了。第 61 行首先调用函数 `chooseFirst` 来获得包含有最早的未输出日志记录的日志设备，然后再考虑是否要输出这条最早的日志记录。如果在启动 `Logcat` 工具时，指定了 `t` 选项，即限定了可以输出的最新日志记录的条数，那么就需要计算所有日志设备中的未输出日志记录的条数。如果未输出的日志记录条数大于可以输出的最大值，即全局变量 `g_tail_lines` 的值，那么就需要将最早的一部分日志记录丢弃；如果没有限定可以输出的最新日志记录的条数，即全局变量 `g_tail_lines` 的值为 `0` ，那么 `Logcat` 工具就会将所有未输出的日志记录输出。处理完成日志设备中的已读取日志记录之后，第 74 行检查 `Logcat` 工具是否以非阻塞的模式来打开日志设备。如果是，由于这时候函数 `select` 是超时返回，即日志设备中没有新的日志记录可读，那么 `Logcat` 工具就直接从第75行退出了。

如果变量 `result` 的值大于 `0` ，即第 56 行的 `if` 语句为 `false` ，那么 `Logcat` 工具就会执行第 77 行到第 92 行代码来处理日志设备中的已读取日志记录。在这种情况下，日志设备中可能还有新的日志记录等待读取，因此，它的处理方式就会与函数 `select` 超时的情况有所不同。这时候如果没有限定可以输出的最新日志记录的条数，即全局变量 `g_tail_lines` 的值为 `0` ，那么 `Logcat` 工具就不用考虑日志设备中是否还有剩余的日志记录未读取了，它可以立即输出那些已经读取的日志记录；如果限定了可以输出的最新日志记录的条数，即全局变量 `g_tail_lines` 的值大于0，那么就要把最早的一部分日志记录删除，直到它们的数量小于等于限定的可以输出的最新日志记录的条数为止。在这种情况下，还需要继续读取日志设备中的其余未读取日志记录，直到所有打开的日志设备都没有新的日志记录可读时， `Logcat` 工具才会将已经读取的日志记录输出。

以上就是日志记录的读取过程。接下来，我们继续分析日志记录的输出过程。

### 4.6.4　日志记录的输出过程
从前面 `4.6.3 `小节的内容可以知道， `Logcat` 工具是通过调用源代码文件 `logcat.cpp` 中的函数 `printNextEntry` 来输出日志记录的。

在前面的 `4.6.2` 小节中还提到，如果全局变量 `g_printBinary` 的值等于 `1` ，那么就说明以二进制格式来输出日志记录。这时候函数 `printNextEntry` 就调用函数 `printBinary` 来处理。 

`system/core/logcat/logcat.cpp`
```cpp
void printBinary(struct logger_entry *buf)
{
    size_t size = sizeof(logger_entry) + buf->len;
    int ret;
    
    do {
        ret = write(g_outFD, buf, size);
    } while (ret < 0 && errno == EINTR);
}
```
由于不需要对日志记录进行解析，即不用将它的优先级、标签以及内容解析出来，因此，函数 `printBinary` 的实现很简单，可直接调用函数 `write` 将它输出到文件或者打印到标准输出中。

如果全局变量 `g_printBinary` 的值等于 `0` ，那么就要以文本格式来输出日志记录。这时候函数 `printNextEntry` 就调用函数 `processBuffer` 来处理。

`system/core/logcat/logcat.cpp`
```cpp
static void processBuffer(log_device_t* dev, struct logger_entry *buf)
{
    int bytesWritten = 0;
    int err;
    AndroidLogEntry entry;
    char binaryMsgBuf[1024];

    if (dev->binary) {
        err = android_log_processBinaryLogBuffer(buf, &entry, g_eventTagMap,
                binaryMsgBuf, sizeof(binaryMsgBuf));
        //printf(">>> pri=%d len=%d msg='%s'\n",
        //    entry.priority, entry.messageLen, entry.message);
    } else {
        err = android_log_processLogBuffer(buf, &entry);
    }
    if (err < 0) {
        goto error;
    }

    if (android_log_shouldPrintLine(g_logformat, entry.tag, entry.priority)) {
        if (false && g_devCount > 1) {
            binaryMsgBuf[0] = dev->label;
            binaryMsgBuf[1] = ' ';
            bytesWritten = write(g_outFD, binaryMsgBuf, 2);
            if (bytesWritten < 0) {
                perror("output error");
                exit(-1);
            }
        }

        bytesWritten = android_log_printLogLine(g_logformat, g_outFD, &entry);

        if (bytesWritten < 0) {
            perror("output error");
            exit(-1);
        }
    }

    g_outByteCount += bytesWritten;

    if (g_logRotateSizeKBytes > 0 
        && (g_outByteCount / 1024) >= g_logRotateSizeKBytes
    ) {
        rotateLogs();
    }

error:
    //fprintf (stderr, "Error processing record\n");
    return;
}
```
前面得到的日志记录只是一块二进制数据，保存在一个 `logger_entry` 结构体中，因此，函数 `processBuffer` 在将它输出之前，首先要将它的内容转换为一个 `AndroidLogEntry` 结构体。 `AndroidLogEntry` 结构体描述了一条日志记录的写入时间、优先级、标签、内容以及写入进程ID。如果日志记录的类型是二进制格式的，即是类型为 `events` 的日志记录，那么函数 `processBuffer` 就会调用函数 `android_log_processBinaryLogBuffer` 对它进行解析；否则，就调用函数 `android_log_processLogBuffer` 对它进行解析。日志记录解析完成之后，函数 `processBuffer` 最后就调用函数 `android_log_printLogLine` 将它输出到文件或者打印到标准输出中。这三个函数的实现我们在后面再详细分析，现在先完成对函数 `processBuffer` 的分析。

一条日志记录解析完成之后， `Logcat` 工具就得到了它的优先级和标签。由于在启动 `Logcat` 工具时，可能设置了日志记录输出过滤器，因此，函数 `processBuffer` 就需要调用函数 `android_log_shouldPrintLine` 判断一条日志记录是否能够输出。在前面的 `4.6.2` 小节中提到， `Logcat` 工具的日志记录输出过滤器列表保存在全局变量 `g_logformat` 中，因此，函数 `processBuffer` 就以它作为参数来调用函数 `android_log_shouldPrintLine` ，判断一条日志记录是否能够输出，它的实现如下所示。

`system/core/liblog/logprint.c`
```cpp
/**
 * returns 1 if this log line should be printed based on its priority
 * and tag, and 0 if it should not
 */
int android_log_shouldPrintLine (
        AndroidLogFormat *p_format, const char *tag, android_LogPriority pri)
{
    return pri >= filterPriForTag(p_format, tag);
}
```
函数 `filterPriForTag` 首先在参数 `p_format` 中检查是否对日志记录标签 `tag` 设置了输出过滤器。如果设置了，那么函数 `filterPriForTag` 就会返回它的过滤优先级。只有这个过滤优先级低于即将要输出的日志记录的优先级时，该日志记录才可以输出。

函数 `filterPriForTag` 的实现如下所示。

`system/core/liblog/logprint.c`
```cpp
static android_LogPriority filterPriForTag(
        AndroidLogFormat *p_format, const char *tag)
{
    FilterInfo *p_curFilter;

    for (p_curFilter = p_format->filters
            ; p_curFilter != NULL
            ; p_curFilter = p_curFilter->p_next
    ) {
        if (0 == strcmp(tag, p_curFilter->mTag)) {
            if (p_curFilter->mPri == ANDROID_LOG_DEFAULT) {
                return p_format->global_pri;
            } else {
                return p_curFilter->mPri;
            }
        }
    }

    return p_format->global_pri;
}
```
第 6 行到第 17 行的 `for` 循环检查在参数 `p_format` 的日志记录输出过滤器列表中是否为日志记录标签 `tag` 设置了输出过滤器。如果设置了，就返回该日志记录标签所对应的优先级；否则，就返回全局设置的日志记录输出优先级，即返回参数 `p_format` 的成员变量 `global_pri` 。另外，如果我们为日志记录标签 `tag` 设置了输出过滤器，但是将该输出过滤器的优先级设置为 `ANDROID_LOG_DEFAULT` ，那么函数 `filterPriForTag` 实际上返回的是全局设置的日志记录输出优先级，如第 12 行代码所示。

回到函数 `processBuffer` 中，如果函数 `android_log_shouldPrintLine` 的返回值为 `true` ，那么它就会先调用函数 `android_log_printLogLine` 输出日志记录，然后再将输出的日志记录的字节回到函数 `processBuffer` 中，如果函数 `android_log_shouldPrintLine` 的返回值为 `true` ，那么它就会先调用函数 `android_log_printLogLine` 输出日志记录，然后再将输出的日志记录的字节数 `bytesWritten` 增加到全局变量 `g_outByteCount` 中，表示到目前为止，一共往文件 `g_outFD` 中输出了多少个字节的日志记录。一旦输出到文件 `g_outFD` 中的日志记录的字节数大于全局变量 `g_logRotateSizeKBytes` 的值时，那么 `Logcat` 就会将接下来的其他日志记录输出到另外一个文件中。全局变量 ` g_logRotateSizeKBytes` 的值是由 `Logcat` 工具的启动选项 `r` 来指定的，如果没有指定该选项，那么全局变量 ` g_logRotateSizeKBytes` 的值就会等于 `0` ，表示将所有的日志记录都输出到同一个文件中。如果全局变量 ` g_logRotateSizeKBytes` 的值大于 `0` ，那么总共可以用来作为日志记录输出文件的个数就由 `Logcat` 工具的选项n来指定。如果没有指定选项 `n` ，那么默认就有四个日志记录输出文件。第 44 行调用函数 `rotateLogs` 来设置下一个日志记录输出文件，它的实现如下所示。

`system/core/logcat/logcat.cpp`
```cpp
static void rotateLogs()
{
    int err;

    // Can't rotate logs if we're not outputting to a file
    if (g_outputFileName == NULL) {
        return;
    }

    close(g_outFD);

    for (int i = g_maxRotatedLogs ; i > 0 ; i--) {
        char *file0, *file1;

        asprintf(&file1, "%s.%d", g_outputFileName, i);

        if (i - 1 == 0) {
            asprintf(&file0, "%s", g_outputFileName);
        } else {
            asprintf(&file0, "%s.%d", g_outputFileName, i - 1);
        }

        err = rename (file0, file1);

        if (err < 0 && errno != ENOENT) {
            perror("while rotating log files");
        }

        free(file1);
        free(file0);
    }

    g_outFD = openLogFile (g_outputFileName);

    if (g_outFD < 0) {
        perror ("couldn't open output file");
        exit(-1);
    }

    g_outByteCount = 0;

}
```
假设在启动 `Logcat` 工具时，通过选项 `f` 来指定日志记录输出文件为 `logfile` ，并且通过选项n来指定日志记录输出文件个数为 3 ，那么函数 `rotateLogs` 就分别将日志记录输出文件设置为 `logfile` 、 `logfile.1` 、 `logfile.2 `和 `logfile.3 `。

**注意**
> 这四个文件是循环使用的，即当文件 `logfile.3` 的大小达到限定的值之后， `Logcat` 工具就将接下来的日志记录重新输出到文件 `logfile` 、 `logfile.1` 和 `logfile.2 `中。依此类推，当文件`logfile.2` 的大小再次达到限定的值之后，最后又将新的日志记录输出到文件 `logfile.3 `中。 

分析完成函数 `processBuffer` 的实现之后，接下来我们开始分析函数 `android_log_processLogBuffer` 、 `android_log_processBinaryLogBuffer` 和 `android_log_printLogLine` 的实现。

首先分析函数 `android_log_processLogBuffer` 的实现，它是用来解析类型为 `main` 、 `system` 和 `radio` 的日志记录的，如下所示。

`system/core/logcat/logcat.cpp`
```cpp
/**
 * Splits a wire-format buffer into an AndroidLogEntry
 * entry allocated by caller. Pointers will point directly into buf
 *
 * Returns 0 on success and -1 on invalid wire format (entry will be
 * in unspecified state)
 */
int android_log_processLogBuffer(struct logger_entry *buf,
                                 AndroidLogEntry *entry)
{
    size_t tag_len;

    entry->tv_sec = buf->sec;
    entry->tv_nsec = buf->nsec;
    entry->priority = buf->msg[0];
    entry->pid = buf->pid;
    entry->tid = buf->tid;
    entry->tag = buf->msg + 1;
    tag_len = strlen(entry->tag);
    entry->messageLen = buf->len - tag_len - 3;
    entry->message = entry->tag + tag_len + 1;

    return 0;
}
```
日志记录的优先级字段的长度为 `1` 个字节，保存在 `logger_entry` 结构体 `buf` 内部的缓冲区 `msg` 的第一个字节中。日志记录的标签字段从 `logger_entry` 结构体 `buf` 内部的缓冲区 `msg` 的第二个字节开始，一直到后面的 `\0` 字符为止，因此，第 19 行可以通过调用函数 `strlen` 来计算它的长度。 `logger_entry` 结构体 `buf` 内部的缓冲区 `msg` 剩余的字节即为日志记录的内容字段，它的长度等于缓冲区的总长度减去日志记录标签的长度，再减去 `1` 个字节的日志记录优先级，以及 `2` 个字符串结束字符 `\0` ，其中一个是日志记录标签字段的，另一个是日志记录内容字段的。

接下来，我们继续分析函数 `android_log_processBinaryLogBuffer` 的实现，它是用来解析类型为 `events` 的日志记录的，我们分段来阅读。

`system/core/liblog/logprint.c`
```cpp
/**
 * Convert a binary log entry to ASCII form.
 *
 * For convenience we mimic the processLogBuffer API.  There is no
 * pre-defined output length for the binary data, since we're free to format
 * it however we choose, which means we can't really use a fixed-size buffer
 * here.
 */
int android_log_processBinaryLogBuffer(struct  ` logger_entry`  *buf,
    AndroidLogEntry *entry, const EventTagMap* map, char* messageBuf,
    int messageBufLen)
{
    size_t inCount;
    unsigned int tagIndex;
    const unsigned char* eventData;

    entry->tv_sec = buf->sec;
    entry->tv_nsec = buf->nsec;
    entry->priority = ANDROID_LOG_INFO;
    entry->pid = buf->pid;
    entry->tid = buf->tid;

    /*
     * Pull the tag out.
     */
    eventData = (const unsigned char*) buf->msg;
    inCount = buf->len;
    if (inCount < 4)
        return -1;
    tagIndex = get4LE(eventData);
    eventData += 4;
    inCount -= 4;

    if (map != NULL) {
        entry->tag = android_lookupEventTag(map, tagIndex);
    } else {
        entry->tag = NULL;
    }
```
第 17 行到 21 行代码用来初始化 `AndroidLogEntry` 结构体 `entry` 中的日志记录写入时间、写入进程 `ID` 以及优先级等信息。从前面 `4.1` 小节中的图 `4-3` 可以知道，类型为 `events` 的日志记录是没有优先级这个字段的，但是为了和其他类型的日志记录统一处理， `Logcat` 工具将它们的优先级设置为 `ANDROID_LOG_INFO` 。

第 26 行得到 `logger_entry` 结构体 `buf` 内部的缓冲区 `msg` 的地址，并且保存在变量 `eventData` 中。由于类型为 `events` 的日志记录的标签是使用一个整数值来描述的，并且保存在 `logger_entry` 结构体 `buf` 内部的缓冲区msg的前面 `4` 个字节中，因此第 30 行就调用函数 `get4LE` 将它获取回来，并且保存在变量 `tagIndex` 中。

函数 `get4LE` 的实现如下所示。

`system/core/liblog/logprint.c`
```cpp
/*
 * Extract a 4-byte value from a byte stream.
 */
static inline uint32_t get4LE(const uint8_t* src)
{
    return src[0] | (src[1] << 8) | (src[2] << 16) | (src[3] << 24);
}
```
它只是简单地将缓冲区 `src` 前面 `4` 个字节的内容组合在一起形成一个整数，然后返回给调用者。

回到函数 `android_log_processBinaryLogBuffer` 中，接下来第 34 行检查参数 `map` 的值是否为 `NULL` 。如果是，就直接将 `AndroidLogEntry` 结构体 `entry` 的成员变量 `tag` 设置为 `NULL` ，表示当前正在处理的一个日志记录的标签值没有对应的描述字符串；否则，第 35 行就会调用函数 `android_lookupEventTag` 在参数 `map` 中找到与日志记录标签值 `tagIndex` 对应的描述字符串。

**注意**
> 参数 `map` 指向一个 `EventTagMap` 结构体，它是 `Logcat` 工具在启动时，通过解析目标设备上的 `/system/etc/event-log-tags` 文件得到的。因此， `Logcat` 工具就可以通过它来找到与日志记录标签值 `tagIndex` 对应的描述字符串。

函数 `android_lookupEventTag` 的实现如下所示。

`system/core/liblog/event_tag_map.c`
```cpp
/*
 * Look up an entry in the map.
 *
 * The entries are sorted by tag number, so we can do a binary search.
 */
const char* android_lookupEventTag(const EventTagMap* map, int tag)
{
    int hi, lo, mid;

    lo = 0;
    hi = map->numTags-1;

    while (lo <= hi) {
        int cmp;

        mid = (lo+hi)/2;
        cmp = map->tagArray[mid].tagIndex - tag;
        if (cmp < 0) {
            /* tag is bigger */
            lo = mid + 1;
        } else if (cmp > 0) {
            /* tag is smaller */
            hi = mid - 1;
        } else {
            /* found */
            return map->tagArray[mid].tagStr;
        }
    }

    return NULL;
}
```
在前面的 `4.6.2` 小节中介绍 `Logcat` 工具的初始化过程时提到， `Logcat` 工具解析完成目标设备上的 `/system/etc/event-log-tags` 文之后，就得到了一个日志记录标签描述表，表中描述了与每一个日志标签所对应的描述字符串，最后会按照标签值从小到大的顺序保存在 `EventTagMap` 结构体内部的 `EventTag` 结构体数组 `tagArray` 中。因此，函数 `android_lookupEventTag` 就可以使用二分法从这个数组中得到与日志记录标签值 `tag` 对应的描述字符串，并且将它返回给调用者。

回到函数 `android_log_processBinaryLogBuffer` 中，继续往下执行。

`system/core/liblog/logprint.c`
```cpp
    /*
     * If we don't have a map, or didn't find the tag number in the map,
     * stuff a generated tag value into the start of the output buffer and
     * shift the buffer pointers down.
     */
    if (entry->tag == NULL) {
        int tagLen;

        tagLen = snprintf(messageBuf, messageBufLen, "[%d]", tagIndex);
        entry->tag = messageBuf;
        messageBuf += tagLen+1;
        messageBufLen -= tagLen+1;
    }

    /*
     * Format the event log data into the buffer.
     */
    char* outBuf = messageBuf;
    size_t outRemaining = messageBufLen-1;      /* leave one for nul byte */
    int result;
    result = android_log_printBinaryEvent(&eventData, &inCount, &outBuf,
                &outRemaining);
```
如果前面没有在 `EventTagMap` 结构体 `map` 中找到即将要输出的日志记录的标签值描述字符串，即第 44 行的 `if` 语句为 `true` ，那么第 47 行就将该标签值作为要输出的日志记录的标签值描述字符串。接着第 59 行调用函数 `android_log_printBinaryEvent` 继续解析日志记录的内容字段。

要输出的日志记录解析完成之后，输出结果就保存在缓冲区 `messageBuf` 中。在调用函数 `android_log_printBinaryEvent` 来解析要输出的日志记录的内容字段之前，第 57 行会在缓冲区   的后面保留一个字节，用来保存一个字符串结束字符 `\0` 。这样， `Logcat` 工具就可以将缓冲区 `messageBuf` 的内容作为一个字符串输出到文件或者打印到标准输出中。

函数 `android_log_printBinaryEvent` 的实现如下所示。

`system/core/liblog/logprint.c`
```cpp
/*
 * Recursively convert binary log data to printable form.
 *
 * This needs to be recursive because you can have lists of lists.
 *
 * If we run out of room, we stop processing immediately.  It's important
 * for us to check for space on every output element to avoid producing
 * garbled output.
 *
 * Returns 0 on success, 1 on buffer full, -1 on failure.
 */
static int android_log_printBinaryEvent(const unsigned char** pEventData,
    size_t* pEventDataLen, char** pOutBuf, size_t* pOutBufLen)
{
    const unsigned char* eventData = *pEventData;
    size_t eventDataLen = *pEventDataLen;
    char* outBuf = *pOutBuf;
    size_t outBufLen = *pOutBufLen;
    unsigned char type;
    size_t outCount;
    int result = 0;

    if (eventDataLen < 1)
        return -1;
    type = *eventData++;
    eventDataLen--;

    //fprintf(stderr, "--- type=%d (rem len=%d)\n", type, eventDataLen);

    switch (type) {
    case EVENT_TYPE_INT:
        /* 32-bit signed int */
        {
            int ival;

            if (eventDataLen < 4)
                return -1;
            ival = get4LE(eventData);
            eventData += 4;
            eventDataLen -= 4;

            outCount = snprintf(outBuf, outBufLen, "%d", ival);
            if (outCount < outBufLen) {
                outBuf += outCount;
                outBufLen -= outCount;
            } else {
                /* halt output */
                goto no_room;
            }
        }
        break;
    case EVENT_TYPE_LONG:
        /* 64-bit signed long */
        {
            long long lval;

            if (eventDataLen < 8)
                return -1;
            lval = get8LE(eventData);
            eventData += 8;
            eventDataLen -= 8;

            outCount = snprintf(outBuf, outBufLen, "%lld", lval);
            if (outCount < outBufLen) {
                outBuf += outCount;
                outBufLen -= outCount;
            } else {
                /* halt output */
                goto no_room;
            }
        }
        break;
    case EVENT_TYPE_STRING:
        /* UTF-8 chars, not NULL-terminated */
        {
            unsigned int strLen;

            if (eventDataLen < 4)
                return -1;
            strLen = get4LE(eventData);
            eventData += 4;
            eventDataLen -= 4;

            if (eventDataLen < strLen)
                return -1;

            if (strLen < outBufLen) {
                memcpy(outBuf, eventData, strLen);
                outBuf += strLen;
                outBufLen -= strLen;
            } else if (outBufLen > 0) {
                /* copy what we can */
                memcpy(outBuf, eventData, outBufLen);
                outBuf += outBufLen;
                outBufLen -= outBufLen;
                goto no_room;
            }
            eventData += strLen;
            eventDataLen -= strLen;
            break;
        }
    case EVENT_TYPE_LIST:
        /* N items, all different types */
        {
            unsigned char count;
            int i;

            if (eventDataLen < 1)
                return -1;

            count = *eventData++;
            eventDataLen--;

            if (outBufLen > 0) {
                *outBuf++ = '[';
                outBufLen--;
            } else {
                goto no_room;
            }

            for (i = 0; i < count; i++) {
                result = android_log_printBinaryEvent(&eventData, &eventDataLen,
                        &outBuf, &outBufLen);
                if (result != 0)
                    goto bail;

                if (i < count-1) {
                    if (outBufLen > 0) {
                        *outBuf++ = ',';
                        outBufLen--;
                    } else {
                        goto no_room;
                    }
                }
            }

            if (outBufLen > 0) {
                *outBuf++ = ']';
                outBufLen--;
            } else {
                goto no_room;
            }
        }
        break;
    default:
        fprintf(stderr, "Unknown binary event type %d\n", type);
        return -1;
    }

bail:
    *pEventData = eventData;
    *pEventDataLen = eventDataLen;
    *pOutBuf = outBuf;
    *pOutBufLen = outBufLen;
    return result;

no_room:
    result = 1;
    goto bail;
}
```
函数 `android_log_printBinaryEvent` 正好是在前面 4.5 小节中介绍的四个日志记录写入函数 `android_util_EventLog_writeEvent_Integer` 、 `android_util_EventLog_writeEvent_Long` 、 `android_util_EventLog_writeEvent_String` 和 `android_util_EventLog_writeEvent_Array` 的逆操作，因此，读者可以对照这四个函数来分析函数 `android_log_printBinaryEvent` 的实现。简单来说，如果日志记录内容只有一个值，那么函数 `android_log_printBinaryEvent` 就会根据它的类型（整数、长整数和字符串）将它从输入缓冲区 `pEventData` 取回来，并且保存到输出缓冲区 `outBuf` 中。当日志记录的内容是一个列表时，函数 `android_log_printBinaryEvent` 就会通过递归调用自己来依次遍历列表中的数据。如果得到的数据是一个整数、长整数或者字符串，那么处理方式就与前面一样；否则，当得到的数据又是一个列表时，函数 `android_log_printBinaryEvent` 就会继续对这个子列表执行同样的遍历操作。

函数 `android_log_printBinaryEvent` 执行完成之后，如果返回值等于 `0` ，那么就说明日志记录解析成功；否则，就说明解析过程中出现了问题，其中，返回值等于 `-1` 表示日志记录缓冲区有误，返回值等于 `1` 表示输出缓冲区 `outBuf` 没有足够的空间来容纳日志记录的内容。

回到函数 `android_log_processBinaryLogBuffer` 中，继续往下执行。

`system/core/liblog/logprint.c`
```cpp
    if (result < 0) {
        fprintf(stderr, "Binary log entry conversion failed\n");
        return -1;
    } else if (result == 1) {
        if (outBuf > messageBuf) {
            /* leave an indicator */
            *(outBuf-1) = '!';
        } else {
            /* no room to output anything at all */
            *outBuf++ = '!';
            outRemaining--;
        }
        /* pretend we ate all the data */
        inCount = 0;
    }

    /* eat the silly terminating '\n' */
    if (inCount == 1 && *eventData == '\n') {
        eventData++;
        inCount--;
    }

    if (inCount != 0) {
        fprintf(stderr,
            "Warning: leftover binary log data (%d bytes)\n", inCount);
    }

    /*
     * Terminate the buffer.  The NUL byte does not count as part of
     * entry->messageLen.
     */
    *outBuf = '\0';
    entry->messageLen = outBuf - messageBuf;
    assert(entry->messageLen == (messageBufLen-1) - outRemaining);

    entry->message = messageBuf;

    return 0;
}
```
变量 `result` 的值是调用函数 `android_log_printBinaryEvent` 得到的返回值。如果它的值小于 `0` ，即第 61 行的 `if` 语句为 `true` ，就说明日志记录内容有误，因此，函数 `android_log_processBinaryLogBuffer` 就不用进一步对它进行处理了，第 63 行直接返回错误码 `-1` ；如果它的值等于 `1` ，即第 64 行的 `if` 语句为 `true` ，那么就说明日志记录输出缓冲区 `messageBuf` 空间不足，这时候函数 `android_log_processBinaryLogBuffer` 就在缓冲区 `messageBuf` 的最后一个字节上写入一个符号 `!` 来说明此种情况。

变量 `inCount` 表示原始的日志记录缓冲区中还有多少个字节未处理。如果它的值等于 1 ，并且剩余未处理的字符为 `\n` ，那么就说明要输出的是一条正常的日志记录，因为每一条类型为 `events` 的日志记录总是以 `\n` 字符结束的。如果要输出的日志记录不是这种情况，那么第 84 行和第 85 行就会输出一条警告信息来说明此种情况。

前面提到，函数 `android_log_processBinaryLogBuffer` 在调用函数 `android_log_printBinaryEvent` 来解析要输出的日志记录的内容字段之前，会在日志记录输出缓冲区 `messageBuf` 的后面保留一个字节，这个字节就是用来写入一个字符串结束符号 `\0` 的，如第92行代码所示。这样， `Logcat` 工具就可以把缓冲区 `messageBuf` 的内容当作一个字符串来使用，即可以直接将它以文本的形式输出到文件或者打印到标准输出中。

最后，我们分析函数 `android_log_printLogLine` 的实现，它是日志记录输出过程中的最后一个步骤，它的实现如下所示。

`system/core/liblog/logprint.c`
```cpp
/**
 * Either print or do not print log line, based on filter
 *
 * Returns count bytes written
 */

int android_log_printLogLine(
    AndroidLogFormat *p_format,
    int fd,
    const AndroidLogEntry *entry)
{
    int ret;
    char defaultBuffer[512];
    char *outBuffer = NULL;
    size_t totalLen;

    outBuffer = android_log_formatLogLine(p_format, defaultBuffer,
            sizeof(defaultBuffer), entry, &totalLen);

    if (!outBuffer)
        return -1;

    do {
        ret = write(fd, outBuffer, totalLen);
    } while (ret < 0 && errno == EINTR);

    if (ret < 0) {
        fprintf(stderr, "+++ LOG: write failed (errno=%d)\n", errno);
        ret = 0;
        goto done;
    }

    if (((size_t)ret) < totalLen) {
        fprintf(stderr, "+++ LOG: write partial (%d of %d)\n", ret,
                (int)totalLen);
        goto done;
    }

done:
    if (outBuffer != defaultBuffer) {
        free(outBuffer);
    }

    return ret;
}
```
第 17 行调用函数 `android_log_formatLogLine` 来格式化要输出的日志记录，并且将最后结果保存在缓冲区 `defaultBuffer` 中。函数 `android_log_formatLogLine` 的实现比较简单，它将要输出的日志记录的内容格式化为 `<PREFIX>+MESSAGE+<SUFFIX>` 的形式。其中， `<PREFIX>` 和 `<SUFFIX>` 的内容取决于 `Logcat` 工具在初始化时所设置的日志记录输出格式，即参数 `p_format` 的内容；而 `MESSAGE` 描述了日志记录的内容字段。有了输出结果缓冲区 `defaultBuffer` 之后，第 23 行到第 25 行的 `while` 循环就调用函数 `write` 将它输出到文件描述符 `fd` 所描述的目标文件中。

在前面的 `4.6.2` 小节中介绍 `Logcat` 工具的初始化过程时提到，如果在启动 `Logcat` 时，指定了选项 `v` ，那么就可以指定日志记录的输出格式。选项 `v` 后面所跟的参数可以为 `brief` 、 `process` 、 `tag` 、 `thread` 、 `raw` 、 `time` 、 `threadtime` 或者 `long` 。每一个参数都对应一个 `AndroidLogPrintFormat` 枚举值，分别为 `FORMAT_BRIEF、FORMAT_PROCESS` 、 `FORMAT_TAG、FORMAT_THREAD` 、 `FORMAT_RAW、FORMAT_TIME` 、 `FORMAT_THREADTIME` 和 `FORMAT_LONG` 。

下面我们就介绍每一个 `AndroidLogPrintFormat` 枚举值所对应的日志记录输出格式。
    （1） `FORMAT_BRIEF` : `<PREFIX>` 和 `<SUFFIX>` 的内容分别为 `<priority>/<tag>(<pid>):` 和 `\n` 。
    （2） `FORMAT_PROCESS` : `<PREFIX>` 和 `<SUFFIX>` 的内容分别为 `<priority>(<pid>)` 和 `(<tag>)\n` 。
    （3） `FORMAT_TAG` : `<PREFIX>` 和 `<SUFFIX>` 的内容分别为 `<priority>/(<tag>):` 和 `\n` 。
    （4） `FORMAT_THREAD` : `<PREFIX>` 和 `<SUFFIX>` 的内容分别为 `<priority>(<pid>:<tid>)` 和 `\n` 。
    （5） `FORMAT_RAW` : `<PREFIX>` 和 `<SUFFIX>` 的内容分别为空值和 `\n` 。
    （6） `FORMAT_TIME` : `<PREFIX>` 和 `<SUFFIX>` 的内容分别为 `<sec>.<nsec><priority>/<tag>(<pid>):` 和 `\n` 。
    （7） `FORMAT_THREADTIME` : `<PREFIX>` 和 `<SUFFIX>` 的内容分别为 `<sec>.<nsec><pid><tid><priority><tag>:` 和 `\n` 。
    （8） `FORMAT_LONG` :  `<PREFIX>` 和  `<SUFFIX>`  的内容分别为 `[<sec>.<nsec><pid>:<tid><priority>/<tag>]` 和 `\n\n` 。

例如，假设应用程序（进程 `ID` 为 `396` ）中调用 `Java` 接口 `android.util.Log` 来往 `Logger` 日志驱动程序中写入了以下一条日志记录 : 

```java
android.util.Log.i("LogTag", "Log Content.");
```
并且假设 `Logcat` 工具在启动时，被指定以 `FORMAT_BRIEF` 格式来输出该日志记录的内容，那么 `Logcat` 工具从 `Logger` 日志驱动程序中读出这条日志记录之后，就会打印出以下的输出 : 

```bash
I/LogTag(396): Log Content.
```
至此，日志记录的输出过程就分析完成了。